<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide Voice Maker - AI音声付き動画生成ツール</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        @keyframes aurora-1 { 0%, 100% { transform: translate(0, 0) scale(1); } 50% { transform: translate(20px, -20px) scale(1.1); } }
        @keyframes aurora-2 { 0%, 100% { transform: translate(0, 0) scale(1); } 50% { transform: translate(-20px, 10px) scale(1.2); } }
        .animate-aurora-1 { animation: aurora-1 15s infinite ease-in-out; }
        .animate-aurora-2 { animation: aurora-2 18s infinite ease-in-out; }
        .loading-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-slate-950">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo } = React;

        // 動作モード
        // - Local: Pythonバックエンド（src/server.py）により、input/へPDF/CSVを上書き保存し、Edge TTS + FFmpegで動画生成
        // - GitHub Pages: 静的ホスティングのため、ブラウザからサーバー側でAI音声生成はできない。
        //   「音声生成」は GitHub Actions（generate-video.yml）で実行する。
        const isLocalMode = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const GITHUB_ACTIONS_WORKFLOW_URL = 'https://github.com/J1921604/Slide-Voice-Maker/actions/workflows/generate-video.yml';

        // Icons
        const Upload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const FileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>;
        const Play = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const Square = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>;
        const Video = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>;
        const Download = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const Mic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>;
        const Volume2 = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>;
        const HelpCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>;
        const X = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;
        const ChevronLeft = () => <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"/></svg>;
        const ChevronRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"/></svg>;
        const Loader2 = ({ className }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"/><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"/><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"/></svg>;
        const Wand2 = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></svg>;
        // (GitHub Actions トリガーUIは要件により削除)

        // 字幕セグメント分割
        const getSubtitleSegments = (script) => {
            if (!script) return [];
            const rawSegments = script.split(/([。、！？!?\n]+)/).filter(s => s.trim().length > 0);
            const mergedSegments = [];
            for (let i = 0; i < rawSegments.length; i += 2) {
                const text = rawSegments[i];
                const punctuation = rawSegments[i + 1] || "";
                mergedSegments.push(text + punctuation);
            }
            const totalChars = mergedSegments.reduce((acc, s) => acc + s.length, 0);
            let charCountAccumulator = 0;
            return mergedSegments.map(text => {
                const startRatio = charCountAccumulator / totalChars;
                charCountAccumulator += text.length;
                const endRatio = charCountAccumulator / totalChars;
                return { text, startRatio, endRatio };
            });
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        const fetchJson = async (url, options = {}, timeoutMs = 2000) => {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);
            try {
                const res = await fetch(url, { ...options, signal: ctrl.signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => '');
                    throw new Error(`${res.status} ${res.statusText}${text ? `: ${text}` : ''}`);
                }
                return await res.json();
            } finally {
                clearTimeout(t);
            }
        };

        // Pure JS silence WAV generator (no AudioContext required)
        // - Some environments (mobile Safari / strict autoplay) can fail to create/resume AudioContext.
        // - For this app's current Web mode, we only need a deterministic, downloadable audio source.
        const createSilentWavBlob = (durationSec, sampleRate = 24000) => {
            const duration = Math.max(Number(durationSec) || 0, 0.01);
            const sr = Math.max(Number(sampleRate) || 24000, 8000);
            const numChannels = 1;
            const bitsPerSample = 16;
            const bytesPerSample = bitsPerSample / 8;

            const numSamples = Math.floor(sr * duration);
            const dataLength = numSamples * numChannels * bytesPerSample;

            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);

            const writeString = (offset, str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            };

            // RIFF header
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(8, 'WAVE');

            // fmt chunk
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // PCM
            view.setUint16(20, 1, true); // format = PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sr, true);
            view.setUint32(28, sr * numChannels * bytesPerSample, true);
            view.setUint16(32, numChannels * bytesPerSample, true);
            view.setUint16(34, bitsPerSample, true);

            // data chunk
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);

            // data is already zero-filled (silence)
            return new Blob([buffer], { type: 'audio/wav' });
        };

        // Web Speech API TTS
        const generateSpeechWebAPI = async (text) => {
            return new Promise((resolve, reject) => {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ja-JP';
                utterance.rate = 1.0;
                
                // 音声を録音
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const dest = audioContext.createMediaStreamDestination();
                const mediaRecorder = new MediaRecorder(dest.stream);
                const chunks = [];
                
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    resolve(URL.createObjectURL(blob));
                };
                
                // 残念ながらWeb Speech APIは直接録音できないので、代替としてダミー音声を返す
                // 実際のプロダクションではEdge TTSやGoogle TTSを使用
                utterance.onend = () => {
                    // 簡易的な無音音声を生成
                    const sampleRate = 24000;
                    const duration = Math.max(text.length * 0.15, 2); // 文字数から推定
                    const numSamples = Math.floor(sampleRate * duration);
                    const audioBuffer = audioContext.createBuffer(1, numSamples, sampleRate);
                    
                    // 無音バッファ
                    const channelData = audioBuffer.getChannelData(0);
                    for (let i = 0; i < numSamples; i++) {
                        channelData[i] = 0;
                    }
                    
                    // WAVとして出力
                    const wavBlob = audioBufferToWav(audioBuffer);
                    resolve(URL.createObjectURL(wavBlob));
                };
                
                utterance.onerror = reject;
                speechSynthesis.speak(utterance);
            });
        };

        // AudioBuffer to WAV
        const audioBufferToWav = (buffer) => {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const dataLength = buffer.length * blockAlign;
            const arrayBuffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(arrayBuffer);
            
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        };

        // PlayerOverlay
        const PlayerOverlay = ({ currentSlide, audioRef, isPlaying }) => {
            const [currentSubtitle, setCurrentSubtitle] = useState("");
            const subtitleSegments = useMemo(() => getSubtitleSegments(currentSlide?.script), [currentSlide]);
            
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleTimeUpdate = () => {
                    if (!currentSlide?.audio) { setCurrentSubtitle(""); return; }
                    const duration = audio.duration;
                    const currentTime = audio.currentTime;
                    if (!duration || !isFinite(duration)) return;
                    const currentRatio = currentTime / duration;
                    const activeSegment = subtitleSegments.find(seg => currentRatio >= seg.startRatio && currentRatio < seg.endRatio);
                    if (activeSegment) setCurrentSubtitle(activeSegment.text);
                    else if (currentRatio >= 1 && subtitleSegments.length > 0) setCurrentSubtitle(subtitleSegments[subtitleSegments.length - 1].text);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                return () => audio.removeEventListener('timeupdate', handleTimeUpdate);
            }, [audioRef, currentSlide, subtitleSegments]);
            
            return (
                <div className="w-full h-[80px] bg-[#1a1a2e] border-t border-white/5 flex items-center justify-center px-8 transition-colors duration-300 flex-shrink-0">
                    <div className="text-white text-lg md:text-2xl font-bold text-center leading-relaxed">{currentSubtitle}</div>
                </div>
            );
        };

        // Main App
        function SlideVoiceMaker() {
            const [slides, setSlides] = useState([]);
            const [scripts, setScripts] = useState([]);
            const [activeSlideIndex, setActiveSlideIndex] = useState(0);
            const [pdfLoading, setPdfLoading] = useState(false);
            const [isExporting, setIsExporting] = useState(false);
            const [exportProgress, setExportProgress] = useState(0);
            const [showHelp, setShowHelp] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [isGeneratingAudio, setIsGeneratingAudio] = useState(false);
            const [pdfFile, setPdfFile] = useState(null);
            const [csvFile, setCsvFile] = useState(null);
            const [statusMessage, setStatusMessage] = useState('');
            const [selectedResolution, setSelectedResolution] = useState('720p');

            // Local backend state
            const [localBackendAvailable, setLocalBackendAvailable] = useState(false);
            const [savedPdfName, setSavedPdfName] = useState('');
            const [outputFiles, setOutputFiles] = useState([]);
            const [selectedOutputName, setSelectedOutputName] = useState('');
            
            // 解像度マッピング
            const RESOLUTION_OPTIONS = [
                { label: '720p (1280x720)', value: '720p', width: 1280, height: 720 },
                { label: '1080p (1920x1080)', value: '1080p', width: 1920, height: 1080 },
                { label: '1440p (2560x1440)', value: '1440p', width: 2560, height: 1440 },
            ];
            
            const getResolutionDimensions = () => {
                const res = RESOLUTION_OPTIONS.find(r => r.value === selectedResolution);
                return res || RESOLUTION_OPTIONS[0];
            };
            
            const audioRef = useRef(null);
            const exportCanvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const csvInputRef = useRef(null);
            const pdfSaveInputRef = useRef(null);

            const refreshOutputFiles = async () => {
                if (!localBackendAvailable) return;
                try {
                    const list = await fetchJson('/api/list_outputs', {}, 4000);
                    const files = (list && list.webm) ? list.webm : [];
                    setOutputFiles(files);
                    if (!selectedOutputName && files.length > 0) {
                        setSelectedOutputName(files[files.length - 1]);
                    }
                } catch (_) {
                    // noop
                }
            };

            const downloadSelectedWebm = () => {
                if (!localBackendAvailable) return;
                if (!selectedOutputName) {
                    setStatusMessage('ダウンロードするWebMを選択してください');
                    return;
                }
                const a = document.createElement('a');
                a.href = `/api/download?name=${encodeURIComponent(selectedOutputName)}`;
                a.download = selectedOutputName;
                a.rel = 'noopener';
                document.body.appendChild(a);
                a.click();
                a.remove();
            };

            // ローカルバックエンド検出（http.server 等で開いた場合は false になり、Web(Pages)相当の挙動にフォールバック）
            useEffect(() => {
                let cancelled = false;
                const check = async () => {
                    if (!isLocalMode) {
                        setLocalBackendAvailable(false);
                        return;
                    }
                    try {
                        const j = await fetchJson('/api/health', {}, 1200);
                        if (!cancelled && j && j.status === 'ok') setLocalBackendAvailable(true);
                    } catch (_) {
                        if (!cancelled) setLocalBackendAvailable(false);
                    }
                };
                check();
                return () => { cancelled = true; };
            }, []);

            // PDF to Images
            const convertPdfToImages = async (file) => {
                const pdfjsLib = window.pdfjsLib;
                if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const images = [];
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport }).promise;
                    images.push(canvas.toDataURL('image/png'));
                }
                return images;
            };

            // CSV Parser (文字化け対処・マルチライン対応)
            const parseCSV = async (file) => {
                const encodings = ['utf-8', 'utf-8-sig', 'shift_jis', 'euc-jp', 'iso-2022-jp'];
                const buf = await file.arrayBuffer();

                const decodeWith = (encoding) => {
                    try {
                        // TextDecoderの方がFileReader(readAsText)より文字コード指定が安定する
                        const dec = new TextDecoder(encoding, { fatal: false });
                        return dec.decode(buf);
                    } catch (_) {
                        return null;
                    }
                };

                // RFC 4180最小対応（複数行セル/エスケープ引用符）
                const parseText = (text) => {
                    const rows = [];
                    let row = [];
                    let field = '';
                    let inQuotes = false;

                    for (let i = 0; i < text.length; i++) {
                        const ch = text[i];
                        const next = text[i + 1];

                        if (ch === '"') {
                            if (inQuotes && next === '"') {
                                field += '"';
                                i++; // escaped quote
                            } else {
                                inQuotes = !inQuotes;
                            }
                            continue;
                        }

                        if (!inQuotes && (ch === ',' || ch === '\n' || ch === '\r')) {
                            row.push(field);
                            field = '';

                            if (ch === ',') {
                                continue;
                            }

                            // newline
                            if (ch === '\r' && next === '\n') i++;
                            rows.push(row);
                            row = [];
                            continue;
                        }

                        field += ch;
                    }

                    // tail
                    if (field.length > 0 || row.length > 0) {
                        row.push(field);
                        rows.push(row);
                    }

                    if (rows.length === 0) return [];

                    // header
                    const header = rows[0].map(v => (v || '').trim().toLowerCase());
                    const idxCol = header.indexOf('index');
                    const scriptCol = header.indexOf('script');
                    if (idxCol === -1 || scriptCol === -1) return [];

                    const scripts = [];
                    for (let r = 1; r < rows.length; r++) {
                        const cols = rows[r];
                        if (!cols || cols.length === 0) continue;
                        const idxRaw = cols[idxCol];
                        const scriptRaw = cols[scriptCol];
                        const idx = Number.parseInt(String(idxRaw ?? '').trim(), 10);
                        if (Number.isNaN(idx)) continue;
                        const script = String(scriptRaw ?? '').trim();
                        scripts.push({ index: idx, script });
                    }
                    return scripts;
                };

                for (const encoding of encodings) {
                    const text = decodeWith(encoding);
                    if (!text) continue;

                    // replacement char が多い場合は外す（ただし日本語でも0でないことはあるので、割合で判定）
                    const replacementCount = (text.match(/\uFFFD/g) || []).length;
                    if (replacementCount > 0 && replacementCount / Math.max(text.length, 1) > 0.001) {
                        continue;
                    }

                    const scripts = parseText(text);
                    if (scripts.length > 0) return scripts;
                }

                throw new Error('CSVの文字コードを認識できませんでした（UTF-8/Shift_JIS等を確認してください）');
            };

            // Handle PDF Upload
            const handlePdfUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setPdfFile(file);
                setPdfLoading(true);
                setStatusMessage('PDF読み込み中...');
                try {
                    // ローカル版: input/ にPDFを上書き保存（バックエンドがある場合のみ）
                    if (localBackendAvailable) {
                        setStatusMessage('PDFをinput/へ保存中...');
                        const fd = new FormData();
                        fd.append('file', file);
                        const res = await fetch('/api/upload/pdf', { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(`PDF保存失敗: ${res.status}`);
                        const j = await res.json();
                        setSavedPdfName(j.filename || file.name);
                        setStatusMessage('PDF保存完了。ブラウザでプレビュー生成中...');
                    } else {
                        setSavedPdfName(file.name);
                    }

                    const images = await convertPdfToImages(file);
                    const newSlides = images.map((image, index) => ({
                        id: crypto.randomUUID(),
                        image,
                        script: scripts[index]?.script || '',
                        audio: null,
                        isGenerating: false
                    }));
                    setSlides(newSlides);
                    setActiveSlideIndex(0);
                    setStatusMessage(`${images.length}ページのPDFを読み込みました`);
                } catch (error) {
                    setStatusMessage(`PDF読み込み失敗: ${error.message}`);
                } finally {
                    setPdfLoading(false);
                }
            };

            // Handle CSV Upload
            const handleCsvUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setCsvFile(file);
                setStatusMessage('原稿CSV読み込み中...');
                try {
                    // ローカル版: input/ にCSVを上書き保存（バックエンドがある場合のみ）
                    if (localBackendAvailable) {
                        setStatusMessage('原稿.csvをinput/へ保存中...');
                        const fd = new FormData();
                        fd.append('file', file);
                        const res = await fetch('/api/upload/csv', { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(`CSV保存失敗: ${res.status}`);
                        setStatusMessage('CSV保存完了。ブラウザで原稿プレビュー反映中...');
                    }

                    const parsedScripts = await parseCSV(file);
                    setScripts(parsedScripts);
                    
                    // スライドがあれば原稿を適用
                    if (slides.length > 0) {
                        setSlides(prev => prev.map((slide, index) => ({
                            ...slide,
                            script: parsedScripts.find(s => s.index === index)?.script || slide.script,
                            audio: null
                        })));
                    }
                    setStatusMessage(`${parsedScripts.length}件の原稿を読み込みました`);
                } catch (error) {
                    setStatusMessage(`CSV読み込み失敗: ${error.message}`);
                }
            };

            // CSV出力（要件によりUIから削除）

            // Generate All Audio (Web Speech API)
            const generateAllAudio = async () => {
                if (isGeneratingAudio) return;

                // ローカルバックエンドが無ければ、GitHub Actionsへ誘導
                if (!localBackendAvailable) {
                    window.open(GITHUB_ACTIONS_WORKFLOW_URL, '_blank', 'noopener,noreferrer');
                    setStatusMessage('GitHub Pagesでは「音声生成」はGitHub Actionsで実行します（Actionsを開きました）。');
                    return;
                }

                if (!savedPdfName) {
                    setStatusMessage('先にPDFをアップロードしてください');
                    return;
                }

                setIsGeneratingAudio(true);
                setStatusMessage('音声生成 & 動画生成中（ローカル）...');
                try {
                    const body = JSON.stringify({ pdf_name: savedPdfName, resolution: selectedResolution });
                    const res = await fetchJson('/api/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body }, 300000);
                    const list = await fetchJson('/api/list_outputs', {}, 4000);
                    const files = (list && list.webm) ? list.webm : [];
                    setOutputFiles(files);

                    const preferred = res && res.webm ? res.webm : '';
                    if (preferred && files.includes(preferred)) {
                        setSelectedOutputName(preferred);
                    } else if (files.length > 0) {
                        setSelectedOutputName(files[files.length - 1]);
                    }

                    setStatusMessage('生成完了（ローカル）。output/ に動画を書き込みました。');
                } catch (e) {
                    setStatusMessage(`生成失敗: ${e.message}`);
                } finally {
                    setIsGeneratingAudio(false);
                }
            };

            // Export Video (WebM)
            const exportVideo = async () => {
                if (isExporting || slides.length === 0) return;
                setIsExporting(true);
                setExportProgress(0);
                setStatusMessage('動画生成開始...');

                const canvas = exportCanvasRef.current;
                const dims = getResolutionDimensions();
                canvas.width = dims.width;
                canvas.height = dims.height;
                const ctx = canvas.getContext('2d');

                const nextFrame = () => new Promise(resolve => requestAnimationFrame(() => resolve()));

                const pickSupportedMimeType = () => {
                    const candidates = [
                        'video/webm;codecs=vp9,opus',
                        'video/webm;codecs=vp8,opus',
                        'video/webm'
                    ];
                    for (const t of candidates) {
                        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
                    }
                    return '';
                };

                try {
                    // 先に画像プリロードして最初のフレームを描画してから録画開始する
                    // （一部環境で、canvasが描画される前にMediaRecorderを開始すると空chunkになりやすい）
                    const preloadedImages = [];
                    for (const slide of slides) {
                        const img = new Image();
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = slide.image;
                        });
                        preloadedImages.push(img);
                    }

                    // 最初のフレームを描画
                    const first = preloadedImages[0];
                    ctx.fillStyle = '#0f0f1a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    const firstScale = Math.min(canvas.width / first.width, (canvas.height - 80) / first.height);
                    const firstW = first.width * firstScale;
                    const firstH = first.height * firstScale;
                    const firstX = (canvas.width - firstW) / 2;
                    const firstY = ((canvas.height - 80) - firstH) / 2;
                    ctx.drawImage(first, firstX, firstY, firstW, firstH);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    await nextFrame();

                    const canvasStream = canvas.captureStream(30);
                    const videoTrack = canvasStream.getVideoTracks()[0] || null;
                    const requestVideoFrame = () => {
                        // Chrome系: CanvasCaptureMediaStreamTrack.requestFrame() が使える
                        try {
                            if (videoTrack && typeof videoTrack.requestFrame === 'function') {
                                videoTrack.requestFrame();
                            }
                        } catch (_) { /* noop */ }
                    };

                    // AudioContextは失敗しうるため「可能なら」音声トラックを付与
                    // （一部環境では音声トラック無しだとMediaRecorderが空chunkになりやすい）
                    let audioCtx = null;
                    let dest = null;
                    let silenceSource = null;
                    try {
                        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        dest = audioCtx.createMediaStreamDestination();

                        if (audioCtx.state === 'suspended') {
                            try { await audioCtx.resume(); } catch (_) { /* noop */ }
                        }

                        silenceSource = (audioCtx.createConstantSource ? audioCtx.createConstantSource() : audioCtx.createOscillator());
                        const silenceGain = audioCtx.createGain();
                        silenceGain.gain.value = 0;
                        if (silenceSource.offset) silenceSource.offset.value = 0;
                        if (silenceSource.frequency) silenceSource.frequency.value = 0;
                        silenceSource.connect(silenceGain);
                        silenceGain.connect(dest);
                        try { silenceSource.start(); } catch (_) { /* noop */ }
                    } catch (e) {
                        console.warn('AudioContext unavailable; recording video-only.', e);
                        audioCtx = null;
                        dest = null;
                        silenceSource = null;
                    }
                    
                    const videoTracks = canvasStream.getVideoTracks();
                    const audioTracks = dest ? dest.stream.getAudioTracks() : [];
                    if (videoTracks.length === 0) {
                        throw new Error('録画用の映像トラックを取得できませんでした');
                    }
                    const combinedStream = new MediaStream([...videoTracks, ...audioTracks]);

                    const mimeType = pickSupportedMimeType();
                    const mediaRecorder = new MediaRecorder(
                        combinedStream,
                        mimeType ? { mimeType } : undefined
                    );
                    const chunks = [];

                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                    };
                    
                    mediaRecorder.ondataavailable = e => {
                        console.log('ondataavailable:', e.data.size);
                        if (e.data.size > 0) chunks.push(e.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        console.log('onstop: chunks count =', chunks.length, 'total size =', chunks.reduce((s, c) => s + c.size, 0));
                        if (chunks.length === 0) {
                            setStatusMessage('動画生成エラー: データが空です');
                            setIsExporting(false);
                            return;
                        }
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        console.log('Final blob size:', blob.size);
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const fileName = pdfFile ? pdfFile.name.replace('.pdf', '.webm') : `video-${Date.now()}.webm`;
                        a.download = fileName;
                        a.click();
                        URL.revokeObjectURL(url);
                        setIsExporting(false);
                        setExportProgress(0);
                        setStatusMessage('動画出力完了！');
                    };

                    // start後すぐは空chunkになりやすいので、開始→少し待つ→描画ループの順にする
                    const recorderStarted = new Promise(resolve => {
                        mediaRecorder.onstart = () => resolve(true);
                    });

                    mediaRecorder.start(250); // 定期的にデータを収集（空chunk対策）

                    // 環境によっては onstart が発火しない/遅延することがあるため、待ちを上限付きにする
                    await Promise.race([recorderStarted, sleep(1000)]);
                    await sleep(150);
                    requestVideoFrame();

                    // 各スライドを順に描画
                    let totalTime = 0;
                    for (let i = 0; i < slides.length; i++) {
                        const slide = slides[i];
                        const img = preloadedImages[i];
                        const duration = slide.duration || Math.max(slide.script.length * 0.12, 3);
                        
                        const startTime = Date.now();
                        const targetDuration = duration * 1000;
                        
                        while (Date.now() - startTime < targetDuration) {
                            // 背景
                            ctx.fillStyle = '#0f0f1a';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // スライド描画
                            const scale = Math.min(canvas.width / img.width, (canvas.height - 80) / img.height);
                            const w = img.width * scale;
                            const h = img.height * scale;
                            const x = (canvas.width - w) / 2;
                            const y = ((canvas.height - 80) - h) / 2;
                            ctx.drawImage(img, x, y, w, h);
                            
                            // 字幕エリア
                            ctx.fillStyle = '#1a1a2e';
                            ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                            
                            // 字幕テキスト
                            const elapsed = (Date.now() - startTime) / targetDuration;
                            const segments = getSubtitleSegments(slide.script);
                            const activeSegment = segments.find(seg => elapsed >= seg.startRatio && elapsed < seg.endRatio);
                            if (activeSegment) {
                                ctx.fillStyle = 'white';
                                ctx.font = 'bold 32px Noto Sans JP, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(activeSegment.text, canvas.width / 2, canvas.height - 40, canvas.width - 80);
                            }

                            // captureStreamはrAF同期 + requestFrame の方が安定する
                            requestVideoFrame();
                            await nextFrame();
                        }
                        
                        totalTime += duration;
                        setExportProgress(Math.round((i + 1) / slides.length * 100));
                        setStatusMessage(`動画生成中... ${i + 1}/${slides.length}`);
                    }

                    // 最後のデータを確実に取得
                    try { mediaRecorder.requestData(); } catch (_) { /* noop */ }
                    await sleep(200);
                    try { mediaRecorder.stop(); } catch (_) { /* noop */ }

                    // Audioノード停止
                    try { silenceSource && silenceSource.stop(); } catch (_) { /* noop */ }
                } catch (error) {
                    setStatusMessage(`動画生成エラー: ${error.message}`);
                    setIsExporting(false);
                }
            };

            // Update script
            const updateScript = (index, newScript) => {
                setSlides(prev => {
                    const newSlides = [...prev];
                    newSlides[index] = { ...newSlides[index], script: newScript, audio: null };
                    return newSlides;
                });
            };

            // 初期画面
            if (slides.length === 0) {
                return (
                    <div className="min-h-screen bg-slate-950 text-white flex flex-col items-center justify-center p-4 relative overflow-hidden">
                        <div className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] bg-violet-600/30 rounded-full blur-[100px] animate-aurora-1" />
                        <div className="absolute bottom-[-10%] right-[-10%] w-[600px] h-[600px] bg-fuchsia-600/20 rounded-full blur-[120px] animate-aurora-2" />
                        
                        <div className="z-10 bg-slate-900/60 backdrop-blur-xl border border-white/10 p-12 rounded-3xl shadow-2xl max-w-2xl w-full text-center">
                            <div className="mb-8 flex justify-center">
                                <div className="bg-gradient-to-r from-violet-500 to-fuchsia-500 p-4 rounded-2xl shadow-lg shadow-violet-500/20">
                                    <Video />
                                </div>
                            </div>
                            <h1 className="text-4xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-violet-400 to-fuchsia-400">
                                Slide Voice Maker
                            </h1>
                            <p className="text-lg text-slate-300 mb-8">
                                PDFスライドと原稿CSVから<br/>ナレーション付き動画を生成
                            </p>
                            
                            {/* ファイル入力ボタン - ホーム画面はPDFのみ */}
                            <div className="space-y-4 mb-8">
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    disabled={pdfLoading}
                                    className="w-full px-6 py-4 bg-white text-slate-900 rounded-xl font-bold text-lg hover:bg-slate-100 transition-all flex items-center justify-center gap-3"
                                >
                                    {pdfLoading ? (
                                        <><Loader2 className="loading-spinner" /> PDF読み込み中...</>
                                    ) : (
                                        <><Upload /> PDFをアップロード</>
                                    )}
                                </button>
                                <input type="file" ref={fileInputRef} onChange={handlePdfUpload} accept=".pdf" className="hidden" />
                            </div>
                            
                            {statusMessage && (
                                <div className="text-sm text-slate-400 mb-4">{statusMessage}</div>
                            )}
                        </div>
                    </div>
                );
            }

            const activeSlide = slides[activeSlideIndex];

            return (
                <div className="h-screen bg-slate-950 text-slate-200 flex flex-col overflow-hidden">
                                        {/*
                                            録画用canvasはdisplay:noneだと環境によってcaptureStreamが空になることがあるため、
                                            DOM上に残したまま画面外へ逃がす。
                                        */}
                                        <canvas ref={exportCanvasRef} className="absolute -left-[10000px] -top-[10000px] opacity-0 pointer-events-none" />
                    
                    {/* Header */}
                    <header className="h-16 bg-slate-900/80 backdrop-blur-md border-b border-white/5 flex items-center justify-between px-6 z-20">
                        <div className="flex items-center gap-3">
                            <div className="w-8 h-8 bg-gradient-to-br from-violet-500 to-fuchsia-600 rounded-lg flex items-center justify-center">
                                <Video />
                            </div>
                            <h1 className="font-bold text-lg">Slide Voice Maker</h1>
                            <button onClick={() => setShowHelp(true)} className="ml-2 text-slate-400 hover:text-white">
                                <HelpCircle />
                            </button>
                        </div>
                        
                        <div className="flex items-center gap-3">
                            {/* ファイル操作ボタン */}
                            <button
                                onClick={() => fileInputRef.current?.click()}
                                className="flex items-center gap-2 px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-sm border border-white/10"
                            >
                                <Upload /> PDF
                            </button>
                            <input type="file" ref={fileInputRef} onChange={handlePdfUpload} accept=".pdf" className="hidden" />
                            
                            <button
                                onClick={() => csvInputRef.current?.click()}
                                className="flex items-center gap-2 px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-sm border border-white/10"
                            >
                                <FileText /> 原稿CSV
                            </button>
                            <input type="file" ref={csvInputRef} onChange={handleCsvUpload} accept=".csv" className="hidden" />
                            
                            <div className="h-6 w-px bg-white/10 mx-1" />
                            
                            <button
                                onClick={generateAllAudio}
                                disabled={isGeneratingAudio || isExporting}
                                className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all ${
                                    isGeneratingAudio 
                                        ? 'bg-slate-800 text-slate-400 cursor-wait' 
                                        : 'bg-indigo-600 hover:bg-indigo-500 text-white shadow-lg shadow-indigo-500/20'
                                }`}
                                title={localBackendAvailable ? 'ローカルで音声+動画を生成し、output/へ上書き保存します' : 'GitHub PagesではGitHub Actionsで音声+動画を生成します'}
                            >
                                {isGeneratingAudio ? (
                                    <><Loader2 className="loading-spinner" /> 生成中...</>
                                ) : (
                                    <><Wand2 /> 音声生成</>
                                )}
                            </button>
                            
                            <select
                                value={selectedResolution}
                                onChange={(e) => setSelectedResolution(e.target.value)}
                                className="px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-sm border border-white/10 cursor-pointer"
                            >
                                {RESOLUTION_OPTIONS.map(opt => (
                                    <option key={opt.value} value={opt.value}>{opt.label}</option>
                                ))}
                            </select>

                            {/* ローカル版: output/*.webm を選択してダウンロード */}
                            {localBackendAvailable && (
                                <>
                                    <select
                                        value={selectedOutputName}
                                        onChange={(e) => setSelectedOutputName(e.target.value)}
                                        onFocus={refreshOutputFiles}
                                        className="px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-sm border border-white/10 cursor-pointer"
                                        title="output/ にあるWebMを選択"
                                    >
                                        <option value="">(output/*.webm を選択)</option>
                                        {outputFiles.map(n => (
                                            <option key={n} value={n}>{n}</option>
                                        ))}
                                    </select>
                                    <button
                                        onClick={downloadSelectedWebm}
                                        disabled={!selectedOutputName}
                                        className="flex items-center gap-2 px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-sm border border-white/10 disabled:opacity-50"
                                        title="選択したWebMをダウンロード"
                                    >
                                        <Download /> 動画WebM出力
                                    </button>
                                </>
                            )}
                            
                            <button
                                onClick={exportVideo}
                                disabled={isExporting || localBackendAvailable}
                                className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-500 hover:to-fuchsia-500 text-white rounded-lg font-medium shadow-lg shadow-violet-500/20 transition-all disabled:opacity-50 relative overflow-hidden"
                                title={localBackendAvailable ? 'ローカル版は「動画WebM出力」でoutput/からダウンロードします' : 'ブラウザでプレビュー用WebMを書き出します（静的動作）'}
                            >
                                {isExporting ? (
                                    <>
                                        <Loader2 className="loading-spinner" />
                                        <span>{exportProgress}%</span>
                                        <div className="absolute bottom-0 left-0 h-1 bg-green-500 transition-all" style={{ width: `${exportProgress}%` }} />
                                    </>
                                ) : (
                                    <><Video /> WebM出力</>
                                )}
                            </button>
                        </div>
                    </header>
                    
                    {/* Status Message */}
                    {statusMessage && (
                        <div className="bg-slate-900/50 border-b border-white/5 px-6 py-2 text-sm text-slate-400">
                            {statusMessage}
                        </div>
                    )}
                    
                    {/* Main Content */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Sidebar */}
                        <div className="w-64 bg-slate-900 border-r border-white/5 flex flex-col">
                            <div className="p-4 border-b border-white/5">
                                <h2 className="text-xs font-bold text-slate-500 uppercase tracking-wider">
                                    Slides ({slides.length})
                                </h2>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2 custom-scrollbar">
                                {slides.map((slide, index) => (
                                    <button
                                        key={slide.id}
                                        onClick={() => setActiveSlideIndex(index)}
                                        className={`w-full text-left p-2 rounded-lg transition-all border ${
                                            activeSlideIndex === index
                                                ? 'bg-slate-800 border-violet-500/50 shadow-md'
                                                : 'hover:bg-slate-800/50 border-transparent hover:border-white/5'
                                        }`}
                                    >
                                        <div className="flex gap-3">
                                            <div className="relative w-16 aspect-video bg-slate-950 rounded overflow-hidden border border-white/10 flex-shrink-0">
                                                <img src={slide.image} className="w-full h-full object-cover" alt={`Slide ${index + 1}`} />
                                                {slide.isGenerating && (
                                                    <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
                                                        <Loader2 className="loading-spinner text-white" />
                                                    </div>
                                                )}
                                            </div>
                                            <div className="flex-1 min-w-0 flex flex-col justify-center">
                                                <span className="text-sm font-medium text-slate-300 truncate">Slide {index + 1}</span>
                                                <div className="flex items-center gap-2 mt-1">
                                                    {slide.audio ? (
                                                        <span className="text-[10px] flex items-center gap-1 text-green-400"><Volume2 /> Audio</span>
                                                    ) : (
                                                        <span className="text-[10px] flex items-center gap-1 text-orange-400"><FileText /> Text</span>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    </button>
                                ))}
                            </div>
                        </div>
                        
                        {/* Preview Area */}
                        <div className="flex-1 flex flex-col bg-slate-950 relative overflow-hidden">
                            <div className="flex-1 flex flex-col min-h-0">
                                <div className="flex-1 bg-slate-950 relative flex items-center justify-center p-4">
                                    <div className="relative w-full h-full max-w-5xl flex flex-col items-center justify-center group">
                                        <div className="relative shadow-2xl rounded-lg overflow-hidden border border-slate-800 bg-black flex-shrink-1 min-h-0">
                                            <img src={activeSlide?.image} className="max-w-full max-h-[calc(100vh-400px)] object-contain mx-auto" alt="Slide Preview" />
                                            <audio 
                                                ref={audioRef} 
                                                src={activeSlide?.audio || ""} 
                                                onPlay={() => setIsPlaying(true)} 
                                                onPause={() => setIsPlaying(false)} 
                                                onEnded={() => { setIsPlaying(false); if(audioRef.current) audioRef.current.currentTime = 0; }} 
                                            />
                                            {activeSlide?.audio && (
                                                <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${isPlaying ? 'opacity-0 group-hover:opacity-100' : 'opacity-100'}`}>
                                                    <button
                                                        onClick={() => {
                                                            const audio = audioRef.current;
                                                            if (!audio) return;
                                                            if (isPlaying) audio.pause();
                                                            else audio.play().catch(() => {});
                                                        }}
                                                        className="w-16 h-16 bg-violet-600/90 hover:bg-violet-500 text-white rounded-full flex items-center justify-center shadow-xl backdrop-blur-sm transition-transform hover:scale-105"
                                                    >
                                                        {isPlaying ? <Square /> : <Play />}
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* Navigation */}
                                    <div className="absolute inset-x-4 top-1/2 -translate-y-1/2 flex justify-between pointer-events-none">
                                        <button
                                            onClick={() => setActiveSlideIndex(Math.max(0, activeSlideIndex - 1))}
                                            disabled={activeSlideIndex === 0}
                                            className="pointer-events-auto p-3 rounded-full bg-slate-900/50 hover:bg-slate-800 text-slate-300 backdrop-blur-sm transition-all disabled:opacity-0"
                                        >
                                            <ChevronLeft />
                                        </button>
                                        <button
                                            onClick={() => setActiveSlideIndex(Math.min(slides.length - 1, activeSlideIndex + 1))}
                                            disabled={activeSlideIndex === slides.length - 1}
                                            className="pointer-events-auto p-3 rounded-full bg-slate-900/50 hover:bg-slate-800 text-slate-300 backdrop-blur-sm transition-all disabled:opacity-0"
                                        >
                                            <ChevronRight />
                                        </button>
                                    </div>
                                </div>
                                
                                <PlayerOverlay currentSlide={activeSlide} audioRef={audioRef} isPlaying={isPlaying} />
                                
                                <div className="h-8 bg-slate-900 border-t border-b border-white/5 flex items-center justify-center gap-4 text-xs text-slate-500 font-mono">
                                    <span>SLIDE {String(activeSlideIndex + 1).padStart(2, '0')} / {String(slides.length).padStart(2, '0')}</span>
                                </div>
                            </div>
                            
                            {/* Script Editor */}
                            <div className="h-[200px] bg-slate-900 flex flex-col flex-shrink-0">
                                <div className="flex items-center justify-between px-4 py-2 border-b border-white/5 bg-slate-900/50">
                                    <span className="text-xs font-bold text-slate-500 uppercase tracking-wider flex items-center gap-2">
                                        <FileText /> Narration Script
                                    </span>
                                    <span className="text-xs text-slate-600">{activeSlide?.script?.length || 0} characters</span>
                                </div>
                                <textarea
                                    value={activeSlide?.script || ""}
                                    onChange={(e) => updateScript(activeSlideIndex, e.target.value)}
                                    className="flex-1 bg-slate-900 p-4 text-slate-300 text-lg leading-relaxed resize-none focus:outline-none focus:bg-slate-800/50 transition-colors"
                                    placeholder="ここに読み上げ原稿を入力してください..."
                                />
                            </div>
                        </div>
                    </div>
                    
                    {/* Help Modal */}
                    {showHelp && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-slate-900 border border-white/10 rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden">
                                <div className="flex items-center justify-between p-6 border-b border-white/10">
                                    <h3 className="text-xl font-bold text-white">🔮 使い方ガイド</h3>
                                    <button onClick={() => setShowHelp(false)} className="text-slate-400 hover:text-white"><X /></button>
                                </div>
                                <div className="p-6 space-y-4">
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 1] PDFアップロード</h4>
                                        <p className="text-sm text-slate-300">プレゼンテーションPDFをアップロードすると、各ページがスライドとして読み込まれます。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 2] 原稿CSV読み込み</h4>
                                        <p className="text-sm text-slate-300">「index,script」形式のCSVを読み込むと、各スライドに原稿が割り当てられます。UTF-8/Shift_JIS対応。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 3] 音声生成 & 動画出力</h4>
                                        <p className="text-sm text-slate-300">「音声生成」で動画を生成します（ローカルはEdge TTSで実声、GitHub PagesはActionsで実声を生成）。</p>
                                        <p className="text-xs text-slate-400 mt-2">
                                            ローカルバックエンドが起動している場合は output/ にWebMを上書き保存し、「動画WebM出力」でダウンロードできます。
                                            GitHub Pagesは静的ホスティングのため、実声（Edge TTS）は GitHub Actions（generate-video.yml）で生成します。
                                        </p>
                                    </div>
                                </div>
                                <div className="p-4 bg-slate-950 border-t border-white/5 flex justify-end">
                                    <button onClick={() => setShowHelp(false)} className="px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg">閉じる</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                </div>
            );
        }

        // Render
        ReactDOM.createRoot(document.getElementById('root')).render(<SlideVoiceMaker />);
    </script>
</body>
</html>
