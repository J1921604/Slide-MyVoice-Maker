<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Slide Studio - AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²ä½“åˆ¶ã®æ§‹ç¯‰</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
  <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide-react.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { height: 100%; }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="env,react" data-plugins="proposal-optional-chaining,proposal-nullish-coalescing-operator">
    const { useState, useRef, useEffect, useMemo } = React;

    // lucide-react(Umd) ãŒèª­ã¿è¾¼ã‚ãªã„/ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã‚‚ç™½ç”»é¢ã«ãªã‚‰ãªã„ã‚ˆã†ã«å®‰å…¨åŒ–
    const __lucide = (typeof window !== 'undefined' && window.lucideReact) ? window.lucideReact : {};
    const __fallbackIcon = (props = {}) => {
      const size = props.size ?? 16;
      const className = props.className ?? '';
      return <span className={className} style={{ display: 'inline-block', width: size, height: size }} />;
    };
    const __makeIcon = (IconImpl) => (typeof IconImpl === 'function' ? (props) => <IconImpl {...props} /> : __fallbackIcon);
    const Upload = __makeIcon(__lucide.Upload);
    const FileText = __makeIcon(__lucide.FileText);
    const Play = __makeIcon(__lucide.Play);
    const Square = __makeIcon(__lucide.Square);
    const Video = __makeIcon(__lucide.Video);
    const Download = __makeIcon(__lucide.Download);
    const Mic = __makeIcon(__lucide.Mic);
    const Volume2 = __makeIcon(__lucide.Volume2);
    const HelpCircle = __makeIcon(__lucide.HelpCircle);
    const X = __makeIcon(__lucide.X);
    const ChevronLeft = __makeIcon(__lucide.ChevronLeft);
    const ChevronRight = __makeIcon(__lucide.ChevronRight);
    const Loader2 = __makeIcon(__lucide.Loader2);
    const Wand2 = __makeIcon(__lucide.Wand2);

    const STORAGE_KEY = 'GEMINI_API_KEY';
    const getStoredApiKey = () => {
      try { return localStorage.getItem(STORAGE_KEY) || ''; } catch { return ''; }
    };
    const setStoredApiKey = (key) => {
      try { localStorage.setItem(STORAGE_KEY, key || ''); } catch {}
    };

    const ttsApiUrlForKey = (key) => `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${encodeURIComponent(key || '')}`;
    const textApiUrlForKey = (key) => `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${encodeURIComponent(key || '')}`;

    // AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²ä½“åˆ¶ã®æ§‹ç¯‰ - å…¨17ã‚¹ãƒ©ã‚¤ãƒ‰ç”¨ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åŸç¨¿
    const preloadedScripts = [
      "AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²ä½“åˆ¶ã®æ§‹ç¯‰ã«ã¤ã„ã¦ã€ã”èª¬æ˜ã„ãŸã—ã¾ã™ã€‚ãƒ‡ã‚¸ã‚¿ãƒ«ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³çµ±æ‹¬éƒ¨ã‚ˆã‚Šã€é–‹ç™ºåŠ›å¼·åŒ–ã«å‘ã‘ãŸè¨ˆç”»æ¡ˆã‚’ãŠä¼ãˆã—ã¾ã™ã€‚",
      "ãªãœä»Šã€AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãŒå¿…è¦ãªã®ã§ã—ã‚‡ã†ã‹ã€‚ãƒ™ãƒ³ãƒ€ãƒ¼ã‹ã‚‰ç´å“ã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã‚„è¨­è¨ˆæ›¸ã®è§£èª­ã«ã‹ã‹ã‚‹æ™‚é–“ã‚’å‰Šæ¸›ã—ã€é–‹ç™ºã‚¹ãƒ”ãƒ¼ãƒ‰ã¨å“è³ªã®ä¸¡ç«‹ã€ã‚¿ã‚¹ã‚¯ç²¾æŸ»ã«ã‚ˆã‚‹ã‚³ã‚¹ãƒˆå‰Šæ¸›ã€ä»•æ§˜ã¨å®Ÿè£…ã®ã‚ºãƒ¬ã‚’ç¸®å°ã™ã‚‹ã“ã¨ãŒç›®çš„ã§ã™ã€‚",
      "ææ¡ˆè€…ã®ã‚­ãƒ£ãƒªã‚¢ã«ã¤ã„ã¦ã§ã™ã€‚ç«åŠ›ç™ºé›»åˆ¶å¾¡ã§ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿è¨“ç·´ã€æµ·å¤–6ã‹å›½ã§ã®çœã‚¨ãƒäº‹æ¥­ã€ç¦å³¶å¾©èˆˆæ”¯æ´ãªã©ã€é€†å¢ƒã‚’ä¹—ã‚Šè¶Šãˆã‚‹ãŸã‚ç‹¬å­¦ã—ã¦ããŸçµŒé¨“ãŒã€AIæ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åŸºç›¤ã¨ãªã£ã¦ã„ã¾ã™ã€‚",
      "JERAã«è»¢ç±ã—ãŸç†ç”±ã«ã¤ã„ã¦ã€‚ç¦å³¶ã¸ã®è²¬ä»»ã‚’æœãŸã™ãŸã‚ã«æ±é›»ãŒå­˜ç¶šã‚’è¨±ã•ã‚ŒãŸã¨ã„ã†ä½¿å‘½æ„Ÿã€ãã—ã¦JERAã«ãŠã‘ã‚‹ä¼æ¥­ä¾¡å€¤å‘ä¸Šã‚’é€šã˜ã¦ã€å°†æ¥ã®æ ªå¼å£²å´ç›Š4å…†å††ã®å®Ÿç¾ã«è²¢çŒ®ã™ã‚‹ã“ã¨ãŒç›®æ¨™ã§ã™ã€‚",
      "æ¥­å‹™ã¨ãƒ‡ã‚¸ã‚¿ãƒ«ã®èåˆã«ã¤ã„ã¦ã§ã™ã€‚è¦ä»¶å®šç¾©ã®æ®µéšã§ã€ãƒ“ã‚¸ãƒã‚¹éƒ¨é–€ã¨ãƒ‡ã‚¸ã‚¿ãƒ«éƒ¨é–€ã®é½Ÿé½¬ã‚’ç¸®å°ã—ã€æ¥­å‹™ã«ç²¾é€šã—ãŸè€…ã¨ãƒ‡ã‚¸ã‚¿ãƒ«ã«ç²¾é€šã—ãŸè€…ãŒå…±åŒé–‹ç™ºã™ã‚‹ä½“åˆ¶ã‚’æ¨™æº–åŒ–ã—ã¦ã„ãã¾ã™ã€‚",
      "AIæ´»ç”¨ã®æŒ‘æˆ¦ã¨ã—ã¦ã€æ–°å’ã‚’5å¹´ã§ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«è‚²æˆã™ã‚‹ã“ã¨ã‚’ç›®æ¨™ã¨ã—ã¦ã„ã¾ã™ã€‚AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã¨ã—ã¦ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆã—ã€éƒ¨é–€ã‚„å½¹è·ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦æœ€é©ãªãƒãƒ¼ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚",
      "AIãŒå¤‰é©ã™ã‚‹é–‹ç™ºã‚µã‚¤ã‚¯ãƒ«ã«ã¤ã„ã¦ã€‚ã‚³ãƒ¼ãƒ‰å®Ÿè£…ã‚„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆã®æ‰‹ä½œæ¥­ã¯AIã«å§”ä»»ã—ã€å…¨ã‚³ãƒ¼ãƒ‰ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’GitHubãƒªãƒã‚¸ãƒˆãƒªã§ä¸€å…ƒç®¡ç†ã€‚AIãŒãƒªãƒã‚¸ãƒˆãƒªã‚’å‚ç…§ã—ã‚³ãƒ³ãƒ†ã‚¯ã‚¹ãƒˆã‚’ç†è§£ã—ã¾ã™ã€‚",
      "é–‹ç™ºåŠ é€Ÿã¨å“è³ªå‘ä¸Šã«ã¤ã„ã¦ã€‚AIãŒãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«æº–æ‹ ã—ãŸã‚³ãƒ¼ãƒ‰ã‚„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ææ¡ˆã—ã€ãƒ«ãƒ¼ãƒ«ã‚’å­¦ç¿’ã—ã¦æˆæœç‰©ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€‚äººé–“ã¯GitHubä¸Šã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«é€²æ—ç¢ºèªã¨å“è³ªç®¡ç†ã€AIã®ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆç²¾æŸ»ã«é›†ä¸­ã—ã¾ã™ã€‚",
      "æŠ€è¡“åŸºç›¤ã®PoCã‚¹ã‚¿ãƒƒã‚¯ã§ã™ã€‚VS Codeã¨GitHub Copilotã€GitHubå…¬å¼spec-kitã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆã€pytestã¨Playwrightã«ã‚ˆã‚‹ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–ã€GitHub Actionsã‚’æ´»ç”¨ã—ã¦ã„ã¾ã™ã€‚",
      "AIæ•™è‚²ã®æ„ç¾©ã«ã¤ã„ã¦ã€‚æ¶ˆè²»ã•ã‚Œã‚‹äººçš„è³‡æºã‹ã‚‰ã€ä¾¡å€¤ã‚’å‰µé€ ã™ã‚‹äººçš„è³‡æœ¬ã¸ã®å¤‰é©ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã«ã¯ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŸ¥è­˜ã¨AIæ´»ç”¨ã‚¹ã‚­ãƒ«ãŒå¿…é ˆã§ã‚ã‚Šã€éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’å«ã‚€å…¨å“¡ãŒAIã‚’ä½¿ã„å€’ã—ã¦æˆæœã‚’å‰µå‡ºã—ã¾ã™ã€‚",
      "å­¦ç¿’æ–‡åŒ–ã®é†¸æˆã§ã™ã€‚æœ€æ–°AIæŠ€è¡“ã‚„ãƒ„ãƒ¼ãƒ«æ“ä½œã‚’å­¦ã³ç¶šã‘ã€AIãƒªãƒ†ãƒ©ã‚·ãƒ¼ã‚’å‘ä¸Šã€‚éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¯RPAå­¦ç¿’ã§é–‹ç™ºãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«å…¨ä½“ã‚’çµŒé¨“ã—ã€ãƒ‡ã‚¸ã‚¿ãƒ«éƒ¨é–€ã®è‹¦åŠ´ã‚’å…±æ„Ÿã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚",
      "æ¬¡ä¸–ä»£ãƒªãƒ¼ãƒ€ãƒ¼è‚²æˆã«ã¤ã„ã¦ã€‚ãƒªãƒ¼ãƒ€ãƒ¼ã¯AIå‰æã§ãƒ“ã‚¸ãƒ§ãƒ³ã‚’æç¤ºã—ã€ãƒ¡ãƒ³ãƒãƒ¼ã®èƒ½åŠ›ã¨æˆæœã‚’é©æ­£ã«è©•ä¾¡ã€‚æœ€é«˜ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ¼è‚²æˆã§ã€AIã¯çœŸä¾¡ã‚’ç™ºæ®ã—ã¾ã™ã€‚",
      "AIæ•™è‚²ã‚³ãƒ¼ã‚¹ä½“ç³»ã§ã™ã€‚åŸºç¤ã‚³ãƒ¼ã‚¹ã¯è¦‹ç¿’ã„ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢å‘ã‘ã«VS Codeã¨GitHub Copilotã‚’æ´»ç”¨ã€‚å°‚é–€ã‚³ãƒ¼ã‚¹ã¯ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢å‘ã‘ã«spec-kitã‚’æ´»ç”¨ã€‚å®Ÿè·µã‚³ãƒ¼ã‚¹ã¯éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢å‘ã‘ã«UiPath Studioã‚’æ´»ç”¨ã—ã¾ã™ã€‚",
      "ä»Šå¾Œã®å±•æœ›ã«ã¤ã„ã¦ã€‚FY25ä¸‹æœŸã‹ã‚‰æ–°å’ãŒåŸºç¤ã‚³ãƒ¼ã‚¹ã‚’å—è¬›é–‹å§‹ã€‚å°‚é–€ã‚³ãƒ¼ã‚¹ã§ã¯ä»•æ§˜ãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºã‚µãƒ³ãƒ—ãƒ«ä½œæˆã¨ãƒ™ãƒ³ãƒ€ãƒ¼æˆæœç‰©ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¤œè¨¼ã‚’å®Ÿæ–½ã€‚å®Ÿè·µã‚³ãƒ¼ã‚¹ã§ã¯UiPath Studioã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¨AutoPilotå°å…¥ã‚’é€²ã‚ã¾ã™ã€‚",
      "ã¾ã¨ã‚ã§ã™ã€‚AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²ä½“åˆ¶ã®æ§‹ç¯‰ã¯ã€æœ€æ–°ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ã‚’ä¾¡å€¤ã®é«˜ã„è³‡ç”£ã«å¤‰æ›ã§ãã‚‹ã€æœ‰èƒ½ãªäººè²¡ã¸ã®æŠ•è³‡ã§ã™ã€‚è‡ªåˆ†ã®å¸‚å ´ä¾¡å€¤ã¨JERAã®ä¼æ¥­ä¾¡å€¤å‘ä¸Šã«è²¢çŒ®ã™ã‚‹ãƒ“ã‚¸ãƒ§ãƒ³ã«å…±æ„Ÿã—ãŸã‚‰ã€å³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚",
      "å³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®2æŠã§ã™ã€‚1ã¤ç›®ã¯è‡ªèµ°ã§å¤‰é©ã€‚åŸºç¤ãƒ»å°‚é–€ã‚³ãƒ¼ã‚¹ã‚’ç‹¬å­¦ã—ã€ãƒ™ãƒ³ãƒ€ãƒ¼æˆæœç‰©ã‚’è‡ªåŠ›ã§ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€æ”¹å–„ç‚¹ã‚’ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã€‚2ã¤ç›®ã¯æ¤œè¨¼ã«å”åŠ›ã€‚ãƒ™ãƒ³ãƒ€ãƒ¼æˆæœç‰©ã‚µãƒ³ãƒ—ãƒ«ã‚’æä¾›ã—ã€å…±åŒã§æ¤œè¨¼ã‚’è¡Œã„ã¾ã™ã€‚",
      "ä»¥ä¸Šã§ã€AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²ä½“åˆ¶ã®æ§‹ç¯‰æ¡ˆã«ã¤ã„ã¦ã®èª¬æ˜ã‚’çµ‚ã‚ã‚Šã¾ã™ã€‚ã”æ¸…è´ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚"
    ];

    const pcmToWav = (pcmBase64, sampleRate = 24000) => {
      const binaryString = window.atob(pcmBase64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
      const buffer = bytes.buffer;
      const wavHeader = new ArrayBuffer(44);
      const view = new DataView(wavHeader);
      const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
      writeString(0, 'RIFF');
      view.setUint32(4, 32 + buffer.byteLength, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, buffer.byteLength, true);
      const blob = new Blob([wavHeader, buffer], { type: 'audio/wav' });
      return URL.createObjectURL(blob);
    };

    const getSubtitleSegments = (script) => {
      if (!script) return [];
      const rawSegments = script.split(/([ã€‚ã€ï¼ï¼Ÿ!?\n]+)/).filter(s => s.trim().length > 0);
      const mergedSegments = [];
      for (let i = 0; i < rawSegments.length; i += 2) {
        const text = rawSegments[i];
        const punctuation = rawSegments[i + 1] || "";
        mergedSegments.push(text + punctuation);
      }
      const totalChars = mergedSegments.reduce((acc, s) => acc + s.length, 0);
      let charCountAccumulator = 0;
      return mergedSegments.map(text => {
        const startRatio = charCountAccumulator / totalChars;
        charCountAccumulator += text.length;
        const endRatio = charCountAccumulator / totalChars;
        return { text, startRatio, endRatio };
      });
    };

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const parseRetryAfterMs = (response) => {
      try {
        const ra = response?.headers?.get?.('retry-after');
        if (!ra) return null;
        // seconds or HTTP date
        const seconds = Number(ra);
        if (Number.isFinite(seconds) && seconds >= 0) return Math.round(seconds * 1000);
        const dateMs = Date.parse(ra);
        if (!Number.isNaN(dateMs)) return Math.max(0, dateMs - Date.now());
        return null;
      } catch {
        return null;
      }
    };

    const fetchWithBackoff = async (url, options, { maxRetries = 5, baseDelayMs = 1500, maxDelayMs = 45000, onWait } = {}) => {
      let lastRes = null;
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        const res = await fetch(url, options);
        lastRes = res;
        if (res.ok) return res;

        const retryable = (res.status === 429) || (res.status >= 500);
        if (!retryable || attempt === maxRetries) return res;

        const headerWait = parseRetryAfterMs(res);
        const expWait = Math.min(maxDelayMs, baseDelayMs * Math.pow(2, attempt));
        const jitter = Math.floor(Math.random() * 500);
        const waitMs = Math.max(0, headerWait ?? (expWait + jitter));
        if (typeof onWait === 'function') onWait({ status: res.status, attempt, waitMs });
        await sleep(waitMs);
      }
      return lastRes;
    };

    const PlayerOverlay = ({ currentSlide, audioRef, isPlaying }) => {
      const [currentSubtitle, setCurrentSubtitle] = useState("");
      const subtitleSegments = useMemo(() => getSubtitleSegments(currentSlide?.script), [currentSlide]);
      useEffect(() => {
        const audio = audioRef.current;
        if (!audio) return;
        const handleTimeUpdate = () => {
          if (!currentSlide?.audio) { setCurrentSubtitle(""); return; }
          const duration = audio.duration;
          const currentTime = audio.currentTime;
          if (!duration || !isFinite(duration)) return;
          const currentRatio = currentTime / duration;
          const activeSegment = subtitleSegments.find(seg => currentRatio >= seg.startRatio && currentRatio < seg.endRatio);
          if (activeSegment) setCurrentSubtitle(activeSegment.text);
          else if (currentRatio >= 1 && subtitleSegments.length > 0) setCurrentSubtitle(subtitleSegments[subtitleSegments.length - 1].text);
        };
        audio.addEventListener('timeupdate', handleTimeUpdate);
        return () => audio.removeEventListener('timeupdate', handleTimeUpdate);
      }, [audioRef, currentSlide, subtitleSegments]);
      return (
        <div className="w-full h-[80px] bg-[#1a1a2e] border-t border-white/5 flex items-center justify-center px-8 transition-colors duration-300 flex-shrink-0">
          <div className="text-white text-lg md:text-2xl font-bold text-center leading-relaxed">{currentSubtitle}</div>
        </div>
      );
    };

    function AISlideStudio() {
      const [apiKey, setApiKey] = useState(getStoredApiKey());
      const [autoGenScripts, setAutoGenScripts] = useState(true);
      const [isGeneratingScripts, setIsGeneratingScripts] = useState(false);
      const [scriptGenProgress, setScriptGenProgress] = useState(0);
      const [lastError, setLastError] = useState("");
      const [statusMessage, setStatusMessage] = useState("");

      const [slides, setSlides] = useState([]);
      const [activeSlideIndex, setActiveSlideIndex] = useState(0);
      const [pdfLoading, setPdfLoading] = useState(false);
      const [isExporting, setIsExporting] = useState(false);
      const [pptxExporting, setPptxExporting] = useState(false);
      const [exportProgress, setExportProgress] = useState(0);
      const [showHelp, setShowHelp] = useState(false);
      const [isPlaying, setIsPlaying] = useState(false);
      const [isGeneratingAudio, setIsGeneratingAudio] = useState(false);
      const audioRef = useRef(null);
      const exportCanvasRef = useRef(null);
      const fileInputRef = useRef(null);

      useEffect(() => {
        // ã€ŒçœŸã£ç™½ã€ã«ãªã£ãŸæ™‚ã«ã€æœ€ä½é™ã‚¨ãƒ©ãƒ¼ã‚’UIã¸å‡ºã™
        const onErr = (e) => {
          const msg = e?.message || e?.reason?.message || e?.error?.message || String(e);
          setLastError(msg);
        };
        window.addEventListener('error', onErr);
        window.addEventListener('unhandledrejection', onErr);
        return () => {
          window.removeEventListener('error', onErr);
          window.removeEventListener('unhandledrejection', onErr);
        };
      }, []);

      const saveApiKey = () => {
        setStoredApiKey(apiKey);
      };

      const handlePdfUpload = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        setPdfLoading(true);
        try {
          setLastError("");
          const { images, texts } = await convertPdfToImagesAndTexts(file);
          const newSlides = images.map((image, index) => ({
            id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + '-' + index),
            image,
            script: preloadedScripts[index] || "",
            audio: null,
            isGenerating: false,
            pageText: texts[index] || ""
          }));
          setSlides(newSlides);
          setActiveSlideIndex(0);

          // ä»»æ„PDFå¯¾å¿œ: APIã‚­ãƒ¼ãŒã‚ã‚Šã€ã‹ã¤è‡ªå‹•ç”ŸæˆONãªã‚‰ã€æŠ½å‡ºãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰åŸç¨¿ã‚’ç”Ÿæˆ
          const key = apiKey || getStoredApiKey();
          if (autoGenScripts && key) {
            await generateScriptsFromPdfTexts(texts, key);
          }
        } catch (error) { alert(`PDFèª­ã¿è¾¼ã¿å¤±æ•—: ${error.message}`); }
        finally { setPdfLoading(false); }
      };

      const convertPdfToImagesAndTexts = async (file) => {
        if (!window.pdfjsLib) throw new Error("PDFå‡¦ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã¿ä¸­ã§ã™ã€‚");
        const pdfjsLib = window.pdfjsLib;
        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const images = [];
        const texts = [];
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: 2.0 });
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height; canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport }).promise;
          images.push(canvas.toDataURL('image/png'));

          // ãƒšãƒ¼ã‚¸ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºï¼ˆã‚¹ã‚­ãƒ£ãƒ³PDFãªã©ã¯ç©ºã«ãªã‚Šå¾—ã‚‹ï¼‰
          try {
            const textContent = await page.getTextContent();
            const pageText = (textContent?.items || [])
              .map((it) => (it && typeof it.str === 'string' ? it.str : ''))
              .filter(Boolean)
              .join(' ')
              .replace(/\s+/g, ' ')
              .trim();
            texts.push(pageText);
          } catch {
            texts.push("");
          }
        }
        return { images, texts };
      };

      const parseJsonStringArray = (raw) => {
        if (!raw) return null;
        const start = raw.indexOf('[');
        const end = raw.lastIndexOf(']');
        if (start === -1 || end === -1 || end <= start) return null;
        const json = raw.slice(start, end + 1);
        try {
          const arr = JSON.parse(json);
          if (Array.isArray(arr) && arr.every((s) => typeof s === 'string')) return arr;
        } catch {
          // ignore
        }
        return null;
      };

      const generateScriptsFromPdfTexts = async (pageTexts, key) => {
        if (!key) return;
        const cleanTexts = (pageTexts || []).map((t) => (t || '').slice(0, 3000));
        if (cleanTexts.length === 0) return;

        setIsGeneratingScripts(true);
        setScriptGenProgress(0);
        setLastError("");
        setStatusMessage("");

        try {
          const batchSize = 5;
          const results = new Array(cleanTexts.length).fill("");

          for (let i = 0; i < cleanTexts.length; i += batchSize) {
            const batch = cleanTexts.slice(i, i + batchSize);
            const prompt = [
              'ã‚ãªãŸã¯æ—¥æœ¬èªã®ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åŸç¨¿ä½œæˆè€…ã§ã™ã€‚',
              'å…¥åŠ›ã¯PDFã‚¹ãƒ©ã‚¤ãƒ‰å„ãƒšãƒ¼ã‚¸ã®æŠ½å‡ºãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚',
              'å‡ºåŠ›ã¯ã€Œãƒšãƒ¼ã‚¸æ•°ã¨åŒã˜é•·ã•ã€ã®JSONé…åˆ—ï¼ˆæ–‡å­—åˆ—ã®ã¿ï¼‰ã§è¿”ã—ã¦ãã ã•ã„ã€‚',
              'å„è¦ç´ ã¯ãã®ãƒšãƒ¼ã‚¸ã®è¦ç‚¹ã‚’å…·ä½“çš„ã«è¨€åŠã—ã€50ã€œ150æ–‡å­—ã€ã§ã™ãƒ»ã¾ã™èª¿ã€å¥ç‚¹ã€Œã€‚ã€ã§çµ‚ãˆã‚‹ã€‚',
              'æ›–æ˜§ãªè¡¨ç¾ï¼ˆã€Œã“ã¡ã‚‰ã‚’ã”è¦§ãã ã•ã„ã€ç­‰ï¼‰ã‚„ãƒšãƒ¼ã‚¸é·ç§»ã ã‘ã®æ–‡ã¯é¿ã‘ã‚‹ã€‚',
              '',
              'ã€å…¥åŠ›ï¼ˆãƒšãƒ¼ã‚¸ã”ã¨ï¼‰ã€‘',
              ...batch.map((t, idx) => `---\n# Page ${i + idx + 1}\n${t || 'ï¼ˆãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºãªã—ã€‚ç”»åƒå†…å®¹ã‚’ä¸€èˆ¬åŒ–ã—ã¦çŸ­ãè¦ç´„ã—ã¦ã€‚ï¼‰'}`),
              '',
              'ã€å‡ºåŠ›å½¢å¼ã€‘',
              '["...","...",...]',
              'â€»å¿…ãšJSONé…åˆ—ã®ã¿ã€‚å‰ç½®ãç¦æ­¢ã€‚'
            ].join('\n');

            const payload = {
              contents: [{ parts: [{ text: prompt }] }],
              generationConfig: { temperature: 0.4, maxOutputTokens: 2048 }
            };

            const res = await fetchWithBackoff(textApiUrlForKey(key), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }, {
              maxRetries: 6,
              baseDelayMs: 2000,
              maxDelayMs: 60000,
              onWait: ({ status, attempt, waitMs }) => {
                const sec = Math.max(1, Math.round(waitMs / 1000));
                setStatusMessage(`åŸç¨¿ç”ŸæˆAPIãŒæ··é›‘ã—ã¦ã„ã¾ã™ï¼ˆ${status}ï¼‰ã€‚${sec}ç§’å¾…ã£ã¦å†è©¦è¡Œä¸­â€¦ï¼ˆ${attempt + 1}å›ç›®ï¼‰`);
              }
            });

            if (!res.ok) {
              if (res.status === 429) {
                throw new Error('Script API Error: 429ï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼‰ã€‚æ™‚é–“ã‚’ç½®ã„ã¦å†å®Ÿè¡Œã™ã‚‹ã‹ã€ã€ŒPDFã‹ã‚‰åŸç¨¿ã‚’è‡ªå‹•ç”Ÿæˆã€ã‚’OFFã«ã—ã¦ãã ã•ã„ã€‚');
              }
              throw new Error(`Script API Error: ${res.status}`);
            }
            const json = await res.json();
            const modelText = (json?.candidates?.[0]?.content?.parts || [])
              .map((p) => p?.text || '')
              .join('')
              .trim();

            const arr = parseJsonStringArray(modelText);
            for (let j = 0; j < batch.length; j++) {
              const fallback = batch[j]
                ? `${batch[j].slice(0, 80)}â€¦ã€‚`.replace(/\s+/g, ' ')
                : 'ã“ã®ãƒšãƒ¼ã‚¸ã®è¦ç‚¹ã‚’ç°¡æ½”ã«ã”èª¬æ˜ã—ã¾ã™ã€‚';
              const s = (arr && arr.length === batch.length ? arr[j] : fallback) || fallback;
              results[i + j] = s.trim().endsWith('ã€‚') ? s.trim() : (s.trim() + 'ã€‚');
            }

            setScriptGenProgress(Math.min(100, Math.round(((i + batch.length) / cleanTexts.length) * 100)));
            setStatusMessage("");
            // å°‘ã—é–“éš”ã‚’ç©ºã‘ã¦ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«å½“ãŸã‚Šã«ããã™ã‚‹
            await sleep(1200);
          }

          setSlides((prev) => prev.map((s, idx) => ({ ...s, script: results[idx] || s.script || '' })));
        } catch (e) {
          setLastError(e?.message || String(e));
          setStatusMessage("");
        } finally {
          setIsGeneratingScripts(false);
          setScriptGenProgress(0);
        }
      };

      const generateSpeechFromText = async (text, retryCount = 0) => {
        if (!text) return null;
        const payload = { contents: [{ parts: [{ text }] }], generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Aoede" } } } } };
        try {
          const key = apiKey || getStoredApiKey();
          if (!key) throw new Error('APIã‚­ãƒ¼ãŒæœªè¨­å®šã§ã™ï¼ˆéŸ³å£°ç”Ÿæˆã«ã¯Gemini APIã‚­ãƒ¼ãŒå¿…è¦ã§ã™ï¼‰ã€‚');
          const response = await fetch(ttsApiUrlForKey(key), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (!response.ok) {
            if ((response.status === 429 || response.status >= 500) && retryCount < 5) { await sleep(Math.pow(2, retryCount) * 1000); return generateSpeechFromText(text, retryCount + 1); }
            throw new Error(`TTS API Error: ${response.status}`);
          }
          const result = await response.json();
          const audioData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
          if (audioData) return pcmToWav(audioData);
          throw new Error("No audio data");
        } catch (e) { return null; }
      };

      const generateAllAudio = async () => {
        if (isGeneratingAudio) return;
        setIsGeneratingAudio(true);
        const indicesToProcess = slides.map((s, i) => (!s.audio && s.script ? i : -1)).filter(i => i !== -1);
        if (indicesToProcess.length === 0) { setIsGeneratingAudio(false); return; }
        const batchSize = 5;
        for (let i = 0; i < indicesToProcess.length; i += batchSize) {
          const batch = indicesToProcess.slice(i, i + batchSize);
          setSlides(prev => prev.map((s, idx) => batch.includes(idx) ? { ...s, isGenerating: true } : s));
          await Promise.allSettled(batch.map(async (idx) => {
            const audioUrl = await generateSpeechFromText(slides[idx].script);
            setSlides(prev => { const newSlides = [...prev]; newSlides[idx] = { ...newSlides[idx], audio: audioUrl, isGenerating: false }; return newSlides; });
          }));
          if (i + batchSize < indicesToProcess.length) await sleep(500);
        }
        setIsGeneratingAudio(false);
      };

      const exportVideo = async () => {
        if (isExporting || slides.length === 0) return;
        setIsExporting(true);
        setExportProgress(0);

        const canvas = exportCanvasRef.current;
        canvas.width = 1920;
        canvas.height = 1160;
        const ctx = canvas.getContext('2d');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const dest = audioCtx.createMediaStreamDestination();
        const canvasStream = canvas.captureStream(30);
        const combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...dest.stream.getAudioTracks()]);
        const mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm;codecs=vp9,opus' });
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºæ•™è‚²-${Date.now()}.webm`;
          a.click();
          setIsExporting(false);
          audioCtx.close();
          setExportProgress(0);
        };

        const slideAreaHeight = 1080;
        const subtitleAreaHeight = 80;
        const SLIDE_GAP = 0.33;

        const drawFrame = (img, subtitleText) => {
          ctx.fillStyle = '#0f0f1a';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          if (img) {
            const scale = Math.min(canvas.width / img.width, slideAreaHeight / img.height);
            const w = img.width * scale;
            const h = img.height * scale;
            const x = (canvas.width - w) / 2;
            const y = (slideAreaHeight - h) / 2;
            ctx.drawImage(img, x, y, w, h);
          }
          ctx.fillStyle = '#1a1a2e';
          ctx.fillRect(0, slideAreaHeight, canvas.width, subtitleAreaHeight);
          if (subtitleText) {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(subtitleText, canvas.width / 2, slideAreaHeight + subtitleAreaHeight / 2, canvas.width - 80);
          }
        };

        try {
          setExportProgress(5);
          const preloadedImages = [];
          for (let i = 0; i < slides.length; i++) {
            const img = new Image();
            await new Promise((resolve, reject) => {
              img.onload = resolve;
              img.onerror = reject;
              img.src = slides[i].image;
            });
            preloadedImages.push(img);
          }

          setExportProgress(10);
          const slideAudioData = [];
          for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            if (slide.audio) {
              const response = await fetch(slide.audio);
              const arrayBuffer = await response.arrayBuffer();
              const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
              slideAudioData.push({ hasAudio: true, buffer: audioBuffer, duration: audioBuffer.duration });
            } else {
              slideAudioData.push({ hasAudio: false, buffer: null, duration: 3.0 });
            }
            setExportProgress(10 + Math.round((i / slides.length) * 10));
          }

          const timeline = [];
          let cumulativeTime = 0;
          for (let i = 0; i < slides.length; i++) {
            const audioDuration = slideAudioData[i].duration;
            const start = cumulativeTime;
            const audioEnd = cumulativeTime + audioDuration;
            const end = audioEnd + SLIDE_GAP;
            timeline.push({ slideIndex: i, start, audioEnd, end, audioDuration });
            cumulativeTime = end;
          }
          const totalDuration = cumulativeTime;

          const allSubtitleSegments = slides.map(slide => getSubtitleSegments(slide.script));

          setExportProgress(25);
          mediaRecorder.start();

          const recordingStartTime = audioCtx.currentTime;
          for (let i = 0; i < slides.length; i++) {
            if (slideAudioData[i].hasAudio && slideAudioData[i].buffer) {
              const source = audioCtx.createBufferSource();
              source.buffer = slideAudioData[i].buffer;
              source.connect(dest);
              source.start(recordingStartTime + timeline[i].start);
            }
          }

          while (true) {
            const elapsed = audioCtx.currentTime - recordingStartTime;
            if (elapsed >= totalDuration) break;
            setExportProgress(25 + Math.round((elapsed / totalDuration) * 70));

            let currentSlideIndex = 0;
            for (let i = 0; i < timeline.length; i++) {
              if (elapsed >= timeline[i].start && elapsed < timeline[i].end) {
                currentSlideIndex = i;
                break;
              }
              if (i === timeline.length - 1) currentSlideIndex = i;
            }

            const currentTimeline = timeline[currentSlideIndex];
            const currentSlide = slides[currentSlideIndex];
            const currentImage = preloadedImages[currentSlideIndex];
            const segments = allSubtitleSegments[currentSlideIndex];

            let subtitleText = "";
            const slideElapsed = elapsed - currentTimeline.start;

            if (slideElapsed < currentTimeline.audioDuration) {
              if (segments.length > 0) {
                const ratio = slideElapsed / currentTimeline.audioDuration;
                const activeSegment = segments.find(seg => ratio >= seg.startRatio && ratio < seg.endRatio);
                if (activeSegment) subtitleText = activeSegment.text;
                else if (ratio >= 1) subtitleText = segments[segments.length - 1].text;
              } else {
                subtitleText = currentSlide.script || "";
              }
            }

            drawFrame(currentImage, subtitleText);
            await sleep(33);
          }

          const lastImage = preloadedImages[preloadedImages.length - 1];
          for (let f = 0; f < 10; f++) {
            drawFrame(lastImage, "");
            await sleep(33);
          }

          setExportProgress(100);
          mediaRecorder.stop();

        } catch (error) {
          console.error("Video export error:", error);
          alert("å‹•ç”»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
          setIsExporting(false);
          audioCtx.close();
        }
      };

      const exportPptx = async () => {
        if (!window.PptxGenJS || slides.length === 0) return;
        setPptxExporting(true);
        try {
          const pptx = new window.PptxGenJS();
          const firstSlide = slides.find(s => s.image);
          if (firstSlide) { const img = new Image(); await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = firstSlide.image; }); const ratio = img.width / img.height; if (Math.abs(ratio - 16/9) < 0.1) pptx.layout = 'LAYOUT_16x9'; else if (Math.abs(ratio - 4/3) < 0.1) pptx.layout = 'LAYOUT_4x3'; else { pptx.defineLayout({ name: 'CUSTOM', width: 10, height: 10 / ratio }); pptx.layout = 'CUSTOM'; } }
          for (const slideData of slides) { const slide = pptx.addSlide(); if (slideData.image) slide.addImage({ data: slideData.image, x: 0, y: 0, w: '100%', h: '100%' }); if (slideData.script) slide.addNotes(slideData.script); }
          await pptx.writeFile({ fileName: `AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºæ•™è‚²-${Date.now()}.pptx` });
        } catch (error) { alert("PPTXæ›¸ãå‡ºã—å¤±æ•—: " + error.message); }
        setPptxExporting(false);
      };

      useEffect(() => {
        const audio = audioRef.current;
        if (audio) { audio.pause(); audio.currentTime = 0; setIsPlaying(false); }
      }, [activeSlideIndex]);

      const handlePreviewPlay = () => {
        const audio = audioRef.current;
        if (!audio || !activeSlide?.audio) return;
        if (isPlaying) { audio.pause(); }
        else { audio.currentTime = audio.currentTime || 0; audio.play().catch(() => {}); }
      };

      const updateScript = (index, newScript) => { setSlides(prev => { const newSlides = [...prev]; newSlides[index] = { ...newSlides[index], script: newScript, audio: null }; return newSlides; }); };

      const regenerateAudio = async (index) => {
        const slide = slides[index];
        if (!slide?.script || slide.isGenerating) return;
        setSlides(prev => { const newSlides = [...prev]; newSlides[index] = { ...newSlides[index], isGenerating: true }; return newSlides; });
        try {
          const audioUrl = await generateSpeechFromText(slide.script);
          setSlides(prev => { const newSlides = [...prev]; newSlides[index] = { ...newSlides[index], audio: audioUrl, isGenerating: false }; return newSlides; });
        } catch (error) {
          setSlides(prev => { const newSlides = [...prev]; newSlides[index] = { ...newSlides[index], isGenerating: false }; return newSlides; });
        }
      };

      if (slides.length === 0) {
        return (
          <div className="min-h-screen bg-slate-950 text-white flex flex-col items-center justify-center p-4 relative overflow-hidden font-sans">
            <div className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] bg-orange-600/30 rounded-full blur-[100px] animate-pulse" style={{animation: 'aurora1 15s infinite ease-in-out'}} />
            <div className="absolute bottom-[-10%] right-[-10%] w-[600px] h-[600px] bg-amber-600/20 rounded-full blur-[120px] animate-pulse" style={{animation: 'aurora2 18s infinite ease-in-out'}} />
            <div className="z-10 bg-slate-900/60 backdrop-blur-xl border border-white/10 p-12 rounded-3xl shadow-2xl max-w-2xl w-full text-center">
              <div className="mb-8 flex justify-center"><div className="bg-gradient-to-r from-orange-500 to-amber-500 p-4 rounded-2xl shadow-lg shadow-orange-500/20"><Video size={48} className="text-white" /></div></div>
              <h1 className="text-4xl font-bold mb-2 bg-clip-text text-transparent bg-gradient-to-r from-orange-400 to-amber-400">AI Slide Studio</h1>
              <h2 className="text-xl font-semibold mb-6 text-slate-300">AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²ä½“åˆ¶ã®æ§‹ç¯‰</h2>
              <p className="text-lg text-slate-400 mb-8">èª­ã¿ä¸Šã’åŸç¨¿ã¯æº–å‚™æ¸ˆã¿ã§ã™ã€‚<br/>PDFã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</p>

              <div className="text-left max-w-md mx-auto mb-6 bg-slate-950/60 border border-orange-500/20 rounded-xl p-4">
                <label className="block text-sm font-bold text-orange-300 mb-2">Gemini APIã‚­ãƒ¼ï¼ˆä»»æ„PDFã®åŸç¨¿ç”Ÿæˆãƒ»éŸ³å£°ç”Ÿæˆã«å¿…è¦ï¼‰</label>
                <input value={apiKey} onChange={(e) => setApiKey(e.target.value)} placeholder="AIza..." className="w-full px-3 py-2 rounded-lg bg-slate-900 text-slate-200 border border-white/10 focus:outline-none focus:border-orange-500/50" />
                <div className="mt-3 flex items-center justify-between gap-3">
                  <label className="flex items-center gap-2 text-sm text-slate-300">
                    <input type="checkbox" checked={autoGenScripts} onChange={(e) => setAutoGenScripts(e.target.checked)} />
                    PDFã‹ã‚‰åŸç¨¿ã‚’è‡ªå‹•ç”Ÿæˆï¼ˆæ¨å¥¨ï¼‰
                  </label>
                  <button onClick={saveApiKey} className="px-3 py-2 bg-orange-600 hover:bg-orange-500 text-white rounded-lg text-sm font-bold">ä¿å­˜</button>
                </div>
                <p className="mt-2 text-xs text-slate-400">ã‚­ãƒ¼æœªè¨­å®šã§ã‚‚PDFè¡¨ç¤ºãƒ»åŸç¨¿ã®æ‰‹å…¥åŠ›ç·¨é›†ã¯å¯èƒ½ã§ã™ï¼ˆéŸ³å£°ç”Ÿæˆã¯ä¸å¯ï¼‰ã€‚</p>
              </div>

              <button onClick={() => fileInputRef.current?.click()} disabled={pdfLoading} className="group relative px-8 py-4 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-bold text-lg hover:from-orange-400 hover:to-amber-400 transition-all active:scale-95 disabled:opacity-70 disabled:cursor-not-allowed w-full max-w-md mx-auto overflow-hidden shadow-lg shadow-orange-500/30">
                {pdfLoading ? <span className="flex items-center justify-center gap-2"><Loader2 className="animate-spin" /> è§£æä¸­...</span> : <span className="flex items-center justify-center gap-2"><Upload size={24} /> PDFã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</span>}
              </button>
              <input type="file" ref={fileInputRef} onChange={handlePdfUpload} accept=".pdf" className="hidden" />

              {lastError && (
                <div className="mt-6 text-left max-w-md mx-auto p-3 rounded-lg border border-red-500/30 bg-red-950/30">
                  <div className="text-sm font-bold text-red-300 mb-1">ã‚¨ãƒ©ãƒ¼</div>
                  <div className="text-xs text-red-200/90 break-words">{lastError}</div>
                </div>
              )}

              {!lastError && statusMessage && (
                <div className="mt-6 text-left max-w-md mx-auto p-3 rounded-lg border border-amber-500/30 bg-amber-950/30">
                  <div className="text-sm font-bold text-amber-300 mb-1">å¾…æ©Ÿä¸­</div>
                  <div className="text-xs text-amber-200/90 break-words">{statusMessage}</div>
                </div>
              )}
            </div>
            <style>{`@keyframes aurora1 { 0%, 100% { transform: translate(0, 0) scale(1); } 50% { transform: translate(20px, -20px) scale(1.1); } } @keyframes aurora2 { 0%, 100% { transform: translate(0, 0) scale(1); } 50% { transform: translate(-20px, 10px) scale(1.2); } }`}</style>
          </div>
        );
      }

      const activeSlide = slides[activeSlideIndex];
      return (
        <div className="h-screen bg-slate-950 text-slate-200 flex flex-col font-sans overflow-hidden">
          <canvas ref={exportCanvasRef} className="hidden" />
          <header className="h-16 bg-slate-900/80 backdrop-blur-md border-b border-orange-500/20 flex items-center justify-between px-6 z-20">
            <div className="flex items-center gap-3">
              <div className="w-8 h-8 bg-gradient-to-br from-orange-500 to-amber-600 rounded-lg flex items-center justify-center"><Video size={18} className="text-white" /></div>
              <h1 className="font-bold text-lg tracking-tight">AI Slide Studio</h1>
              <span className="text-sm text-orange-400 ml-2">AIãƒ‰ãƒªãƒ–ãƒ³é–‹ç™ºãƒ»æ•™è‚²</span>
              <button onClick={() => setShowHelp(true)} className="ml-2 text-slate-400 hover:text-white transition-colors"><HelpCircle size={18} /></button>
            </div>
            <div className="flex items-center gap-3">
              <div className="hidden lg:flex items-center gap-2 bg-slate-950/50 border border-white/10 rounded-lg px-3 py-2">
                <span className="text-xs text-slate-400">APIã‚­ãƒ¼</span>
                <input value={apiKey} onChange={(e) => setApiKey(e.target.value)} onBlur={saveApiKey} placeholder="æœªè¨­å®š" className="w-56 bg-transparent text-xs text-slate-200 focus:outline-none" />
                <label className="flex items-center gap-2 text-xs text-slate-300">
                  <input type="checkbox" checked={autoGenScripts} onChange={(e) => setAutoGenScripts(e.target.checked)} />
                  åŸç¨¿è‡ªå‹•ç”Ÿæˆ
                </label>
              </div>

              <button onClick={generateAllAudio} disabled={isGeneratingAudio || isExporting} className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all ${isGeneratingAudio ? 'bg-slate-800 text-slate-400 cursor-wait' : 'bg-orange-600 hover:bg-orange-500 text-white shadow-lg shadow-orange-500/20'}`}>
                {isGeneratingAudio ? <Loader2 size={16} className="animate-spin" /> : <Wand2 size={16} />}{isGeneratingAudio ? 'ç”Ÿæˆä¸­...' : 'éŸ³å£°ç”Ÿæˆ'}
              </button>
              <div className="h-6 w-px bg-white/10 mx-1" />
              <button onClick={exportPptx} disabled={pptxExporting} className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-amber-600 to-yellow-600 hover:from-amber-500 hover:to-yellow-500 text-white rounded-lg font-medium shadow-lg shadow-amber-500/20 transition-all disabled:opacity-50">
                {pptxExporting ? <Loader2 size={16} className="animate-spin" /> : <FileText size={16} />}PPTX
              </button>
              <button onClick={exportVideo} disabled={isExporting} className="flex items-center gap-2 px-4 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg font-medium border border-orange-500/30 transition-all disabled:opacity-50 relative overflow-hidden">
                {isExporting ? <><Loader2 size={16} className="animate-spin" /><span>{exportProgress}%</span><div className="absolute bottom-0 left-0 h-1 bg-orange-500 transition-all duration-300" style={{ width: `${exportProgress}%` }} /></> : <><Video size={16} /> å‹•ç”»</>}
              </button>
            </div>
          </header>

          {(isGeneratingScripts || lastError || statusMessage) && (
            <div className="px-6 py-2 bg-slate-900 border-b border-white/5 text-sm flex items-center justify-between">
              <div className="flex items-center gap-3">
                {isGeneratingScripts ? (
                  <>
                    <Loader2 size={16} className="animate-spin text-orange-400" />
                    <span className="text-slate-300">åŸç¨¿ã‚’PDFã‹ã‚‰ç”Ÿæˆä¸­â€¦ {scriptGenProgress}%</span>
                  </>
                ) : statusMessage ? (
                  <span className="text-amber-300">{statusMessage}</span>
                ) : (
                  <span className="text-red-300">ã‚¨ãƒ©ãƒ¼: {lastError}</span>
                )}
              </div>
              <div className="text-xs text-slate-500">â€»ã‚¹ã‚­ãƒ£ãƒ³PDFã¯ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºãŒå¼±ãã€è¦ç´„ç²¾åº¦ãŒè½ã¡ã¾ã™</div>
            </div>
          )}
          <div className="flex-1 flex overflow-hidden">
            <div className="w-64 bg-slate-900 border-r border-orange-500/10 flex flex-col">
              <div className="p-4 border-b border-white/5"><h2 className="text-xs font-bold text-orange-400 uppercase tracking-wider">Slides ({slides.length})</h2></div>
              <div className="flex-1 overflow-y-auto p-2 space-y-2 custom-scrollbar">
                {slides.map((slide, index) => (
                  <button key={slide.id} onClick={() => setActiveSlideIndex(index)} className={`w-full text-left p-2 rounded-lg transition-all border ${activeSlideIndex === index ? 'bg-slate-800 border-orange-500/50 shadow-md' : 'hover:bg-slate-800/50 border-transparent hover:border-white/5'}`}>
                    <div className="flex gap-3">
                      <div className="relative w-16 aspect-video bg-slate-950 rounded overflow-hidden border border-white/10 flex-shrink-0">
                        <img src={slide.image} className="w-full h-full object-cover" alt={`Slide ${index + 1}`} />
                        {slide.isGenerating && <div className="absolute inset-0 bg-black/50 flex items-center justify-center"><Loader2 size={12} className="animate-spin text-white" /></div>}
                      </div>
                      <div className="flex-1 min-w-0 flex flex-col justify-center">
                        <span className="text-sm font-medium text-slate-300 truncate block">Slide {index + 1}</span>
                        <div className="flex items-center gap-2 mt-1">{slide.audio ? <span className="text-[10px] flex items-center gap-1 text-green-400"><Volume2 size={10} /> Audio</span> : <span className="text-[10px] flex items-center gap-1 text-orange-400"><FileText size={10} /> Text</span>}</div>
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>
            <div className="flex-1 flex flex-col bg-slate-950 relative overflow-hidden">
              <div className="flex-1 flex flex-col min-h-0">
                <div className="flex-1 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-900 via-slate-950 to-slate-950 relative flex items-center justify-center p-4">
                  <div className="relative w-full h-full max-w-5xl flex flex-col items-center justify-center group">
                    <div className="relative shadow-2xl rounded-lg overflow-hidden border border-slate-800 bg-black flex-shrink-1 min-h-0">
                      <img src={activeSlide?.image} className="max-w-full max-h-[calc(100vh-400px)] object-contain mx-auto" alt="Slide Preview" />
                      <audio ref={audioRef} src={activeSlide?.audio || ""} onPlay={() => setIsPlaying(true)} onPause={() => setIsPlaying(false)} onEnded={() => { setIsPlaying(false); if(audioRef.current) audioRef.current.currentTime = 0; }} />
                      {activeSlide?.audio && <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${isPlaying ? 'opacity-0 group-hover:opacity-100' : 'opacity-100'}`}><button onClick={handlePreviewPlay} className="w-16 h-16 bg-orange-600/90 hover:bg-orange-500 text-white rounded-full flex items-center justify-center shadow-xl backdrop-blur-sm transition-transform hover:scale-105 active:scale-95">{isPlaying ? <Square size={24} fill="currentColor" /> : <Play size={24} fill="currentColor" className="ml-1" />}</button></div>}
                    </div>
                  </div>
                  <div className="absolute inset-x-4 top-1/2 -translate-y-1/2 flex justify-between pointer-events-none">
                    <button onClick={() => setActiveSlideIndex(Math.max(0, activeSlideIndex - 1))} disabled={activeSlideIndex === 0} className="pointer-events-auto p-3 rounded-full bg-slate-900/50 hover:bg-slate-800 text-slate-300 backdrop-blur-sm transition-all disabled:opacity-0"><ChevronLeft size={32} /></button>
                    <button onClick={() => setActiveSlideIndex(Math.min(slides.length - 1, activeSlideIndex + 1))} disabled={activeSlideIndex === slides.length - 1} className="pointer-events-auto p-3 rounded-full bg-slate-900/50 hover:bg-slate-800 text-slate-300 backdrop-blur-sm transition-all disabled:opacity-0"><ChevronRight size={32} /></button>
                  </div>
                </div>
                <PlayerOverlay currentSlide={activeSlide} audioRef={audioRef} isPlaying={isPlaying} />
                <div className="h-8 bg-slate-900 border-t border-b border-orange-500/10 flex items-center justify-center gap-4 text-xs text-orange-400 font-mono"><span>SLIDE {String(activeSlideIndex + 1).padStart(2, '0')} / {String(slides.length).padStart(2, '0')}</span></div>
              </div>
              <div className="h-[200px] bg-slate-900 flex flex-col flex-shrink-0">
                <div className="flex items-center justify-between px-4 py-2 border-b border-white/5 bg-slate-900/50">
                  <span className="text-xs font-bold text-orange-400 uppercase tracking-wider flex items-center gap-2"><FileText size={12} /> Narration Script</span>
                  <div className="flex items-center gap-3">
                    <span className="text-xs text-slate-600">{activeSlide?.script?.length || 0} characters</span>
                    <button onClick={() => regenerateAudio(activeSlideIndex)} disabled={!activeSlide?.script || activeSlide?.isGenerating || isGeneratingAudio} className="flex items-center gap-1 px-2 py-1 text-xs font-medium rounded transition-all disabled:opacity-40 disabled:cursor-not-allowed bg-slate-800 hover:bg-slate-700 text-slate-300 border border-orange-500/30">
                      {activeSlide?.isGenerating ? <Loader2 size={12} className="animate-spin" /> : <Mic size={12} />}
                      {activeSlide?.isGenerating ? 'ç”Ÿæˆä¸­...' : 'å†ç”Ÿæˆ'}
                    </button>
                  </div>
                </div>
                <textarea value={activeSlide?.script || ""} onChange={(e) => updateScript(activeSlideIndex, e.target.value)} className="flex-1 bg-slate-900 p-4 text-slate-300 text-lg leading-relaxed resize-none focus:outline-none focus:bg-slate-800/50 transition-colors font-medium" placeholder="ã“ã“ã«èª­ã¿ä¸Šã’åŸç¨¿ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..." />
              </div>
            </div>
          </div>
          {showHelp && (
            <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
              <div className="bg-slate-900 border border-orange-500/20 rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden">
                <div className="flex items-center justify-between p-6 border-b border-white/10 bg-gradient-to-r from-slate-900 to-slate-800"><h3 className="text-xl font-bold text-white flex items-center gap-2"><span className="text-2xl">ğŸ”®</span> ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰</h3><button onClick={() => setShowHelp(false)} className="text-slate-400 hover:text-white"><X size={24} /></button></div>
                <div className="p-6 space-y-4">
                  <div className="bg-slate-800/50 rounded-lg p-4 border border-orange-500/10"><h4 className="font-bold text-orange-400 mb-2">[STEP 1] PDFã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h4><p className="text-sm text-slate-300">ä»»æ„ã®PDFã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°ã€PDFã®æŠ½å‡ºãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ãƒšãƒ¼ã‚¸æ•°åˆ†ã®èª­ã¿ä¸Šã’åŸç¨¿ã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã™ã€‚</p></div>
                  <div className="bg-slate-800/50 rounded-lg p-4 border border-orange-500/10"><h4 className="font-bold text-orange-400 mb-2">[STEP 2] ç·¨é›†ã¨éŸ³å£°ç”Ÿæˆ</h4><p className="text-sm text-slate-300">ä¸‹éƒ¨ã®ã‚¨ãƒªã‚¢ã§åŸç¨¿ã‚’è‡ªç”±ã«ç·¨é›†ã§ãã¾ã™ã€‚<span className="text-white font-bold bg-orange-600/50 px-1 rounded">éŸ³å£°ç”Ÿæˆ</span> ãƒœã‚¿ãƒ³ã§AIãƒŠãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒéŸ³å£°ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</p></div>
                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-amber-950/30 rounded-lg p-4 border border-amber-500/20"><h4 className="font-bold text-amber-400 mb-2 flex items-center gap-2"><FileText size={16}/> PPTX</h4><p className="text-xs text-amber-200/80">åŸç¨¿ãŒã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒãƒ¼ãƒˆã«å…¥ã£ãŸãƒ‘ãƒ¯ãƒã‚’DLã€‚</p></div>
                    <div className="bg-orange-950/30 rounded-lg p-4 border border-orange-500/20"><h4 className="font-bold text-orange-400 mb-2 flex items-center gap-2"><Video size={16}/> å‹•ç”»</h4><p className="text-xs text-orange-200/80">éŸ³å£°ã¨å­—å¹•ãŒåŒæœŸã—ãŸãƒ—ãƒ¬ã‚¼ãƒ³å‹•ç”»(WebM)ã‚’ä½œæˆã€‚</p></div>
                  </div>
                </div>
                <div className="p-4 bg-slate-950 border-t border-white/5 flex justify-end"><button onClick={() => setShowHelp(false)} className="px-6 py-2 bg-orange-600 hover:bg-orange-500 text-white rounded-lg transition-colors">é–‰ã˜ã‚‹</button></div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<AISlideStudio />);
  </script>
</body>
</html>
