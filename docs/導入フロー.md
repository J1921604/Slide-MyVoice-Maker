
# 📑 Spec Kit 導入フロー

---

copilot
Update GitHub Copilot CLI? (y/N): y
/login

---

J1921604
Slide-Voice-Maker
001-Slide-Voice-Maker

---

## 0. GitHub リポジトリ準備（手動作業）

**新規リポジトリの場合のみ実施**
1. GitHub にログインし「New repository」をクリック
2. 「Public」で空のリポジトリを作成
   - ⚠️ **重要:** README・.gitignore・ライセンスファイルは追加しない
   - **理由:** 初期ファイルを追加すると初回 push 時に履歴の衝突が発生するため

---

## 1. ローカル環境の準備

### 新規リポジトリの場合

リポジトリをクローン
cd C:\Users\J1921604\spec-kit
git clone https://github.com/J1921604/Slide-Voice-Maker

または手動でフォルダ作成
```powershell
mkdir Slide-Voice-Maker
cd Slide-Voice-Maker
code .
```

**目的:** 
- 作業フォルダを作成し、VSCode を起動
- `code .` はエディタ起動のみで、Git リポジトリは作成されない

### 既存プロジェクトの場合

既存フォルダを VSCode で開く（このステップはスキップ）

---

## 2. Git の初期化（未初期化の場合のみ）

```powershell
git init
```

**目的:** 現在のディレクトリをローカル Git リポジトリとして初期化

**確認方法:**
```powershell
# .git フォルダの存在確認
Test-Path .git
```

**注意:** 
- 既に `.git` が存在する場合は不要
- 誤って親ディレクトリで実行しないよう、VSCode のワークスペースパスを確認

---

## 3. uv のインストール（未インストールの場合のみ）

### uv の確認

```powershell
# uv がインストールされているか確認
uv --version
```

### uv のインストール方法

**Windows の場合:**
```powershell
# PowerShell で uv をインストール
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```

**インストール後の確認:**
```powershell
# PowerShell を再起動後、バージョン確認
uv --version
# 出力例: uv 0.4.x (または最新バージョン)
```

**目的:**
- uv は Python パッケージマネージャーで、Spec Kit の実行に必要
- `uvx` コマンドで Spec Kit を実行可能にする

**参考情報:**
- 公式サイト: https://docs.astral.sh/uv/
- uv は Rust で書かれた高速な Python パッケージマネージャー

**トラブルシューティング:**

❌ **エラー: "uv : 用語 'uv' は...認識されない"**
```powershell
# 原因: uv がインストールされていない、またはパスが通っていない

# 解決方法 1: PowerShell を再起動
# インストール後、新しいターミナルセッションで再試行

# 解決方法 2: パスを手動で確認
$env:Path
# uv のインストールパスが含まれているか確認
# 通常: C:\Users\<ユーザー名>\.cargo\bin
```

❌ **エラー: "ExecutionPolicy エラー"**
```powershell
# 実行ポリシーを一時的に変更
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

# 再度インストールを試行
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```

---

## 4. Spec Kit の初期化

```powershell
# アップグレード
uv tool install specify-cli --force --from git+https://github.com/github/spec-kit.git
```

```powershell
uvx --from git+https://github.com/github/spec-kit.git specify init --here --ai copilot
```

**目的:** Spec Kit のテンプレートファイルとディレクトリ構造を生成

**重要:** 
- `--here` オプションを**必ず**付ける
- `specify init Slide-Voice-Maker` とすると二重にフォルダが作成される原因となる
- この時点では `/specs` フォルダは作成されない（機能仕様作成時に自動生成される）

---

## 5. 初回コミット

```powershell
git add .
git commit -m "chore(init): initialize project with Spec Kit"
```

**目的:** Spec Kit 導入直後の状態を履歴に記録

---

## 6. 改行コード設定（Windows 環境での推奨設定）

### 🔧 改行コードの統一設定

**背景:**
- Windows（CRLF）と Unix/Linux（LF）では改行コードが異なる
- Git は "LF will be replaced by CRLF" という警告を出すことがある
- リポジトリで改行ルールを統一しないと、無意味な差分やマージ競合が発生する

**推奨設定:**
1. リポジトリに `.gitattributes` を追加（チーム全体で統一）
2. ローカルで `core.autocrlf` を設定（Windows の推奨）

---

### 📝 .gitattributes の作成

**ルートディレクトリに `.gitattributes` ファイルを作成:**

```powershell
# .gitattributes を作成（UTF-8 で保存）
Set-Content -Path .gitattributes -Value @"
# Normalize all text files automatically
* text=auto

# Markdown and documentation files use LF
*.md text eol=lf

# PowerShell scripts use CRLF
*.ps1 text eol=crlf

# Shell scripts use LF
*.sh text eol=lf

# JSON/YAML/text files use LF
*.json text eol=lf
*.text text eol=lf
*.yml text eol=lf

# Binary files should not be converted
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.zip binary
*.exe binary
*.dll binary
"@ -Encoding UTF8
```

**目的:**
- テキストファイルの改行コードをリポジトリレベルで統一
- Markdown ファイル（仕様書等）は LF に統一
- PowerShell スクリプトは Windows 標準の CRLF を使用

---

### ⚙️ Git のローカル設定

```powershell
# Windows での推奨設定
git config --global core.autocrlf true
git config --global core.safecrlf warn

# 設定の確認
git config --global core.autocrlf
git config --global core.safecrlf
```

**設定の意味:**
- `core.autocrlf true`: チェックアウト時に CRLF へ変換、コミット時に LF へ変換
- `core.safecrlf warn`: 不可逆な変換が発生する場合に警告

---

### 🔄 既存ファイルの改行コードを正規化

```powershell
# 1. 現在の変更状態を確認
git status

# 2. インデックスをクリアして .gitattributes を反映
git rm --cached -r .

# 3. すべてのファイルを再登録（改行コードが正規化される）
git add .

# 4. 正規化をコミット（Conventional Commits 準拠）
git commit -m "chore: normalize line endings via .gitattributes"
```

**注意:**
- `git rm --cached -r .` はインデックスから削除するのみで、作業ツリーのファイルは削除されない
- 改行コードの変更により、大量の差分が表示される場合がある

---

### ✅ 確認方法

```powershell
# .gitattributes が作成されたことを確認
Test-Path .gitattributes

# Git の設定を確認
git config --list | Select-String "autocrlf|safecrlf"

# 次回以降、警告が出ないことを確認
git add .
# 警告が出なければ成功
```

**期待される結果:**
- `git add .` 実行時に "LF will be replaced by CRLF" 警告が出ない
- `.gitattributes` がリポジトリに含まれている

---

### 📝 `settings.json`で指示を記述

```powershell
# ディレクトリ作成（既にあってもOK）
New-Item -ItemType Directory -Path .vscode -Force | Out-Null

# 統合 JSON を UTF-8 で保存（Here-Stringは @" で開始、行頭の "`@ で終了）
Set-Content -Path .vscode/settings.json -Value @"
{
  "chat.promptFilesRecommendations": {
    "speckit.constitution": true,
    "speckit.specify": true,
    "speckit.plan": true,
    "speckit.tasks": true,
    "speckit.implement": true
  },
  "chat.tools.terminal.autoApprove": {
    ".specify/scripts/bash/": true,
    ".specify/scripts/powershell/": true
  },
  "github.copilot.chat.commitMessageGeneration.instructions": [
    { "text": "日本語で出力する" },
    { "text": "ワークスペース内の全ファイル全文を末尾まで解析する" },
    { "text": "トークン制限まで中断せず全てのタスクを実行する" },
    { "text": "トークン制限で中断しても簡略化せず品質を低下させない" },
    { "text": "トークン制限の範囲で生成ドキュメントを繰り返しブラッシュアップする" },
    { "text": "文字化け対策として UTF-8 エンコーディングを使用する" },
    { "text": "正常に動作するまで繰り返し検証しエラー修正を完了する" },
    { "text": "フローチャート等の Mermaid 図を挿入し構文エラーを修正する" },
    { "file": ".github/copilot-commit-message-instructions.md" }
  ]
}
"@ -Encoding UTF8
```

### 📝 Conventional Commits 規約に準拠

```powershell
# 1) ディレクトリを作成（既にあっても OK）
New-Item -ItemType Directory -Path .github -Force | Out-Null

# 2) ファイルをUTF-8で作成（Here-String を正しく閉じる）
Set-Content -Path .github/copilot-commit-message-instructions.md -Value @"
コミットメッセージは Conventional Commits 規約に準拠すること。

## フォーマット

<type>[optional scope]: <description>

[optional body]

[optional footer(s)]

## Type

- `feat`: 新機能の追加
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響しない変更(空白、フォーマット、セミコロンの欠落など)
- `refactor`: バグ修正も機能追加もしないコード変更
- `perf`: パフォーマンスを向上させるコード変更
- `test`: 不足しているテストの追加や既存のテストの修正
- `build`: ビルドシステムや外部依存関係に影響する変更(例: npm, webpack)
- `ci`: CI設定ファイルやスクリプトの変更
- `chore`: その他の変更(src や test ファイルを変更しないもの)
- `revert`: 以前のコミットを取り消す

## 基本ルール

- descriptionは日本語で50文字以内とすること。
- 破壊的な変更の場合は、`!`をtypeの後に追加すること。

## 例

feat: ユーザー認証機能を追加

JWTベースの認証システムをリフレッシュトークン付きで実装。
"@ -Encoding UTF8
```

---

## 7. リモートリポジトリの設定と初回 push（新規のみ）

### 🛡️ 競合を防ぐ安全な手順

**前提条件の確認:**
- ✅ GitHub で空のリポジトリ（https://github.com/J1921604/Slide-Voice-Maker）を作成済み
- ✅ README・.gitignore・ライセンスファイルは**追加していない**
- ✅ ローカルで Spec Kit の初期化と初回コミットが完了済み

---

### 📝 完全な push 手順

```powershell
# 1. 現在のブランチ名を確認
git branch
```
```powershell
# 2. ブランチ名を main に統一（必要な場合のみ）
git branch -M main
```
```powershell

# 3. リモートリポジトリを追加
git remote add origin https://github.com/J1921604/Slide-Voice-Maker.git
```
```powershell

# 4. リモートの設定確認
# 出力例:
# origin  https://github.com/J1921604/Slide-Voice-Maker.git (fetch)
# origin  https://github.com/J1921604/Slide-Voice-Maker.git (push)
git remote -v
```
```powershell
# 5. 初回 push（-u オプションで upstream を設定）
git push -u origin main
```

**目的:**
- ローカルの main ブランチをリモートの main ブランチに push
- `-u origin main` で今後の push/pull を簡略化

---

### ✅ 成功時の出力例

```
Enumerating objects: X, done.
Counting objects: 100% (X/X), done.
Delta compression using up to Y threads
Compressing objects: 100% (X/X), done.
Writing objects: 100% (X/X), Z.ZZ KiB | Z.ZZ MiB/s, done.
Total X (delta Y), reused Z (delta W), pack-reused 0
To https://github.com/J1921604/Slide-Voice-Maker.git
 * [new branch]      main -> main
Branch 'main' set up to track remote branch 'main' from 'origin'.
```

---

### 🔍 トラブルシューティング

#### ❌ エラー: "remote origin already exists"

**原因:** 既にリモートが設定されている

**解決方法:**
```powershell
# 既存のリモートを削除
git remote remove origin

# 再度リモートを追加
git remote add origin https://github.com/J1921604/Slide-Voice-Maker.git
```

または:
```powershell
# リモート URL を上書き
git remote set-url origin https://github.com/J1921604/Slide-Voice-Maker.git
```

---

#### ❌ エラー: "failed to push some refs"

**原因:** リモートに存在しない履歴がある（GitHub でファイルを追加してしまった場合）

**解決方法:**
```powershell
# リモートの変更を取得してマージ（履歴が異なる場合も許容）
git pull origin main --allow-unrelated-histories

# コンフリクトが発生した場合は手動で解決後、ステージングしてマージコミット
git add .
git commit -m "chore: merge remote changes from origin/main"
```

```powershell
# 再度 push
git push -u origin main
```

---

#### ❌ エラー: "src refspec main does not match any"

**原因:** ローカルに main ブランチが存在しない、またはコミットがない

**解決方法:**
```powershell
# コミット履歴を確認
git log

# コミットがない場合、初回コミットを作成
git add .
git commit -m "chore(init): initialize project with Spec Kit"

# ブランチ名を main に変更
git branch -M main
```

```powershell
# 再度 push
git push -u origin main
```

---

### 📊 push 後の確認

```powershell
# リモートブランチの確認
# 出力例:
# * main
#   remotes/origin/main
git branch -a
```

```powershell
# 最新のコミット履歴を確認
git log --oneline -5
```

**GitHub での確認:**
1. https://github.com/J1921604/Slide-Voice-Maker にアクセス
2. `main` ブランチに `.specify` フォルダと `.gitattributes` ファイルが存在することを確認
3. コミット履歴に "Initialize project with Spec Kit" が表示されることを確認

---

### 🔄 以降の push 手順

初回 push 後は、以下のシンプルなコマンドで push 可能:
```powershell
git status
```

```powershell
git pull origin main
```

```powershell
git add .
```

```powershell
# .github\copilot-commit-message-instructions.mdに基づきコミット
git commit -m "docs: 修正"
```

```powershell
git push origin main
```

---

## 8. Spec Kit ファイルの作成

以下、textはCopilotChatに入力する

### 1️⃣ プロジェクト憲法

```text
/speckit.constitution 
ワークスペース内の全ファイル全文を末尾まで解析（済の場合スキップ）する
トークン制限まで中断せず全てのタスクを実行する
トークン制限で中断する、簡略化など品質を低下させない
コード品質、テスト基準、ユーザー体験の一貫性、およびパフォーマンス要件に焦点を当てた原則を日本語で作成する

品質:
  - ワークスペース内の全ファイル全文を末尾まで解析する
  - トークン制限まで中断せず全てのタスクを実行する
  - トークン制限で中断する、簡略化など品質を低下させない
  - トークン制限まで、生成したドキュメントを繰り返しブラッシュアップする
  - 文字化け対策としてUTF-8エンコーディングする
  - テンプレートから生成したドキュメントの英語の部分を確実に削除する

principles:
  - テスト駆動開発を徹底し、仕様に対する検証を必須とする
  - セキュリティ要件を機能要件より優先する
  - パフォーマンス閾値を定量化し、受入基準に組み込む

constraints:
  - 機密データの平文保存を禁止（暗号化・ハッシュ化必須）
  - 外部依存はバージョン固定により再現性を確保する
  - 仕様と実装の乖離をレビューで検知・是正する

governance:
  - 作業順序：憲法→仕様→計画→タスク→検証→実装→レビュー
  - 仕様と実装はブランチ（spec/impl）で分離する
  - 重大変更にはレビュー承認を必須とする

ブランチ戦略:
  - 仕様ブランチ（mainブランチから派生）
    git checkout main
    git checkout -b <番号>-<短い名前>
  - 実装ブランチ（仕様ブランチから派生）
    git checkout 001-<topic>
    git checkout -b feature/impl-<番号>-<短い名前>

開発方針:
  - フロントエンドとバックエンドを同時に起動するコードも生成する
  - 正常に動作するまで繰り返し検証しエラー修正を完了しない
  - フローチャートなどMermaid図v11準拠を挿入する
    Mermaid v11対応のベストプラクティス
	1. gitGraph使用時の注意:
	   日本語を避けるか、flowchart/graph形式を使用
	   tag:構文は非推奨、代わりにノードで表現
	   ${{}}などの特殊文字をノードラベルに使用できない
	2. 日本語対応:
	   flowchart、graph、sequenceDiagramは日本語完全対応
	   ノードラベル、エッジラベル、Noteで日本語使用可能
	   gitGraph構文は日本語コミットメッセージに対応していない
	3. 推奨構文:
	   ブランチ戦略: flowchart TB + subgraph
	   プロセスフロー: flowchart TD/LR
	   時系列: sequenceDiagram
	   状態遷移: stateDiagram-v2
```

**役割:** プロジェクト全体の原則・制約・ガバナンスを定義

---

### 📝 憲法ファイルのコミットと push

**憲法ファイルを Git に追加してコミット:**
```powershell
# 1. 憲法ファイルをステージングに追加
git add .specify/memory/constitution.md

# 2. 憲法ファイルをコミット
git commit -m "docs: add constitution 1.0.0 with TDD, security-first, and performance principles"
```

**push前の確認:**
```powershell
# 現在のブランチ名を確認（main であることを確認）
git symbolic-ref --short HEAD
# 出力例: main

# リモートリポジトリの設定を確認
git remote -v
# 出力例:
# origin  https://github.com/J1921604/Slide-Voice-Maker.git (fetch)
# origin  https://github.com/J1921604/Slide-Voice-Maker.git (push)
```

**リモートへ push:**
```powershell
# 憲法ファイルのコミットをリモートに push
git push -u origin main
```

**期待される出力:**
```
Enumerating objects: X, done.
Counting objects: 100% (X/X), done.
Delta compression using up to Y threads
Compressing objects: 100% (X/X), done.
Writing objects: 100% (X/X), Z.ZZ KiB | Z.ZZ MiB/s, done.
Total X (delta Y), reused Z (delta W), pack-reused 0
To https://github.com/J1921604/Slide-Voice-Maker.git
   [前のコミット]..[新しいコミット]  main -> main
```

**GitHub での確認:**
1. https://github.com/J1921604/Slide-Voice-Maker にアクセス
2. `.specify/memory/constitution.md` ファイルが存在することを確認
3. コミット履歴に "docs: create constitution 1.0.0..." が表示されることを確認

---

### 2️⃣ 機能仕様

```text
/speckit.specify 
ワークスペース内の全ファイル全文を末尾まで解析（済の場合スキップ）する
トークン制限まで中断せず全てのタスクを実行する
トークン制限で中断する、簡略化など品質を低下させない
ブランチ戦略に基づき仕様ブランチ（mainブランチから派生）を作成する
フォルダ全ファイルに基づき日本語で作成する
フローチャートなどMermaid図v11準拠を挿入する
GitHubPagesで動作するアプリを作成する
ワンコマンドでlocalhostが開いた後Powershellを閉じるファイルを作成する
spec.mdとrequirements.mdを生成した後、ブランチ戦略に基づき実装ブランチ（仕様ブランチから派生）を作成する
トークン制限まで、生成したドキュメントを繰り返しブラッシュアップする
テンプレートから生成したドキュメントの英語の部分を確実に削除する
```

**役割:** 機能要件と非機能要件を詳細に定義

**実行結果:**
- 仕様ブランチの自動作成（例: `001-Slide-Voice-Maker`）
- `/specs/001-Slide-Voice-Maker/spec.md` ファイルの生成
- `/specs/001-Slide-Voice-Maker/checklists/requirements.md` チェックリストの生成

---

### 📂 /specs フォルダの配置確認とトラッキング

**フォルダ構造の確認:**
```powershell
# specs フォルダの存在を確認
# 出力: True
Test-Path specs

# specs フォルダの内容を確認
Get-ChildItem specs -Recurse
```

**誤配置の修正（念のため）:**
```powershell
# 誤配置の修正（環境によってはワークスペース外に生成される場合があります）
if (Test-Path ../specs) { Move-Item ../specs ./specs }
```

**Git 管理下に追加:**
```powershell
# specs フォルダを Git 管理下に追加
git add specs/

# 機能仕様をコミット
git commit -m "docs: add functional specifications"
```

**検証方法:**
- VSCode のエクスプローラで「Slide-Voice-Maker/specs/001-Slide-Voice-Maker」を確認
- 親ディレクトリに specs が残っていないことを確認
- `spec.md` と `checklists/requirements.md` が存在することを確認

**コミット確認:**
```powershell
# 最新のコミット履歴を確認
git log --oneline -3
```

---

### 🔍 Git ブランチ戦略の確認事項

**仕様ブランチと実装ブランチの分離:**

Spec Kit では仕様と実装を別ブランチで管理する:

#### 📋 ブランチ命名規則

```powershell
# 1. 仕様ブランチ（/speckit.specify で自動作成）
# 形式: <番号>-<短い名前>
# 例: 001-Slide-Voice-Maker

# 2. 実装ブランチ（/speckit.implement 実行前に手動作成）
# 形式: feature/impl-<番号>-<短い名前>
# 例: feature/impl-001-Slide-Voice-Maker
```

#### 🔀 ブランチの派生関係

mainブランチから仕様ブランチを派生させる（自動作成）
```powershell
# mainブランチから仕様ブランチを派生させる（自動作成）
git checkout main
git checkout -b 001-Slide-Voice-Maker
```

仕様ブランチから実装ブランチを派生させる（手動作成）
```powershell
# 仕様ブランチから実装ブランチを派生させる（手動作成）
git checkout 001-Slide-Voice-Maker
git checkout -b feature/impl-001-Slide-Voice-Maker
```

#### ✅ ブランチ確認コマンド

```powershell
# 現在のブランチ名を確認
git branch
```

```powershell
# すべてのブランチを確認（ローカル + リモート）
git branch -a
```

```powershell
# ブランチの派生元を確認
git log --graph --oneline --all --decorate
```

#### 📊 期待されるブランチ構造

```
main (初期設定・憲法)
  └─ 001-Slide-Voice-Maker (仕様)
       └─ feature/impl-001-Slide-Voice-Maker (実装)
```

#### 🚨 よくある間違い

❌ **間違い 1: main から直接実装ブランチを作成**
```powershell
# NG: 仕様が含まれないブランチになります
git checkout main
git checkout -b feature/impl-001-Slide-Voice-Maker
```

✅ **正しい方法: 仕様ブランチから実装ブランチを作成**
```powershell
git checkout 001-Slide-Voice-Maker
git checkout -b feature/impl-001-Slide-Voice-Maker
```

---

❌ **間違い 2: 実装を仕様ブランチで直接行う**
```powershell
# NG: 仕様と実装が混在します
git checkout 001-Slide-Voice-Maker
# ここで実装を開始（誤り）
```

✅ **正しい方法: 実装専用ブランチを作成**
```powershell
git checkout 001-Slide-Voice-Maker
git checkout -b feature/impl-001-Slide-Voice-Maker
# ここで実装を開始（正しい）
```

---

#### 📝 実装ブランチでの作業確認

```powershell
# 1. 実装ブランチにいることを確認
# 出力例: * feature/impl-001-Slide-Voice-Maker
git branch
```

```powershell
# 2. 仕様ファイルが含まれていることを確認
# 出力: True
Test-Path specs/001-Slide-Voice-Maker/spec.md
```

```powershell
# 3. 実装コミットの記録（ブランチ作成時など）
git add .
git commit -m "feat: create implementation branch"
```

```powershell
git push -u origin feature/impl-001-Slide-Voice-Maker
```

---

### 3️⃣ 実装計画

```text
/speckit.plan 
ワークスペース内の全ファイル全文を末尾まで解析（済の場合スキップ）する
トークン制限まで中断せず全てのタスクを実行する
トークン制限で中断する、簡略化など品質を低下させない
仕様ブランチのspec.mdとrequirements.mdに基づき日本語で作成する
フローチャートなどMermaid図v11準拠を挿入する
トークン制限まで、生成したドキュメントを繰り返しブラッシュアップする
テンプレートから生成したドキュメントの英語の部分を確実に削除する
```

**目的:** 仕様から実装計画を自動生成

**生成物:** `specs/001-Slide-Voice-Maker/plan.md` ファイル

**計画に含まれる内容:**
- 技術スタック選定
- アーキテクチャ設計
- データモデル設計
- API契約定義
- パフォーマンス目標

---

### 4️⃣ タスク分解

```text
/speckit.tasks 
ワークスペース内の全ファイル全文を末尾まで解析（済の場合スキップ）する
トークン制限まで中断せず全てのタスクを実行する
トークン制限で中断する、簡略化など品質を低下させない
plan.mdに基づき日本語で作成する
フローチャートやガントチャートなどMermaid図v11準拠を挿入する
トークン制限まで、生成したドキュメントを繰り返しブラッシュアップする
テンプレートから生成したドキュメントの英語の部分を確実に削除する
```

**目的:** 計画を実装可能なタスクに分解

**生成物:** `specs/001-Slide-Voice-Maker/tasks.md` ファイル

**タスクに含まれる内容:**
- 実装順序（Phase 0 → Phase 4）
- TDDサイクル（Red-Green-Refactor）
- Acceptance Criteria
- 依存関係
- 見積もり時間
- Constitution Compliance

---

### 5️⃣ 整合性検証

```text
/speckit.check
```

**目的:** 憲法と仕様の整合性を検証

**実行タイミング:**
- 機能仕様作成後（/speckit.specify 実行後）
- 計画生成後（/speckit.plan 実行後）
- タスク分解後（/speckit.tasks 実行後）
- 実装開始前（/speckit.implement 実行前）

**チェック内容:**
- 憲法の原則に違反していないか
- 必須要件（FR）がすべて定義されているか
- 成功基準（SC）が測定可能か
- セキュリティ要件が含まれているか

---

### 6️⃣ 実装

```text
/speckit.implement 
ワークスペース内の全ファイル全文を末尾まで解析（済の場合スキップ）する
トークン制限まで中断せず全てのタスクを実行する
トークン制限で中断する、簡略化など品質を低下させない
実装を優先する
憲法100％遵守、テストコード100％完了、正常に動作まで検証を繰り返し修正する
tasks.mdの実装した項目にマークする
デプロイ前にローカルでビルドとプレビューを検証し正常に機能が動作するまで繰り返し修正する
GitHub Pagesへの自動デプロイGitHub Actionsワークフロー動作を検証し繰り返し修正する
デプロイ先GitHubリポジトリ名
https://github.com/J1921604/Slide-Voice-Maker
GitHub Pagesが表示されるまで動作を検証し繰り返し修正する
手動でGitHub Pagesの設定が必要な場合、手順を提示する
自動と手動のGitHub Pagesデプロイ手順.mdを保存する
他AIが完璧に再現できる仕様書.mdに更新する
フローチャートなどMermaid図v11準拠を挿入する
```

**役割:** 技術選定と実装詳細を定義

---

### 7️⃣ レビュー（任意）

```text
/speckit.review
criteria:
  security:
    - 入力検証: すべての外部入力をサニタイズ
    - 認可: リソースアクセスの権限確認
    - 秘匿情報: 環境変数・シークレット管理の徹底
  
  performance:
    - 閾値検証: レスポンスタイム測定
    - 計測ポイント: APM ツールでの監視
    - 負荷テスト: 想定トラフィックの 2 倍
  
  operations:
    - ログ: 構造化ログ（JSON 形式）
    - メトリクス: Prometheus + Grafana
    - 監視: ヘルスチェックエンドポイント
    - アラート: 重大度別の通知設定
  
  spec_alignment:
    - 憲法との整合性
    - 仕様・計画・タスクとの一貫性
    - 受入基準の充足確認

process:
  reviewer_roles:
    - dev: 開発者レビュー
    - sec: セキュリティレビュー
    - ops: 運用レビュー
    - qa: 品質保証レビュー
  
  approvals_required: 2
  
  blocking_conditions:
    - 憲法と仕様の不整合
    - セキュリティ重大欠陥（CVSS 7.0 以上）
    - 受入基準の未達成
```

**役割:** レビュープロセスと承認基準を定義

---

#### ✅ ブランチ確認コマンド

```powershell
# 現在のブランチ名を確認
git branch
```

```powershell
# または
git symbolic-ref --short HEAD
```

```powershell
# すべてのブランチを確認（ローカル + リモート）
git branch -a
```

```powershell
# ブランチの派生元を確認
git log --graph --oneline --all --decorate
```

**main ブランチへのマージ（オプション）:**

仕様ブランチ
```powershell
# main に切り替え
git checkout main
```

```powershell
# 001-Slide-Voice-Maker に切り替え
git checkout 001-Slide-Voice-Maker
```

```powershell
# feature/impl-001-Slide-Voice-Maker に切り替え
git checkout feature/impl-001-Slide-Voice-Maker
```

```powershell
# 最新を取得
git fetch origin
git pull origin main
```

```powershell
# 仕様ブランチをマージ
git merge 001-Slide-Voice-Maker
```

```powershell
# リモートに反映
git push origin main
```

```powershell
# ローカルブランチ削除
git branch -d 001-Slide-Voice-Maker
```

```powershell
# リモートブランチ削除（必要なら）
git push origin --delete 001-Slide-Voice-Maker
```

⚠️ この場合、そのブランチでの作業内容は main に残りません。

```powershell
# マージせずに強制削除（履歴を残さない）
git branch -D 001-Slide-Voice-Maker
```

```powershell
# リモートも消す場合
git push origin --delete 001-Slide-Voice-Maker
```

実装ブランチ

```powershell
# main に切り替え
git checkout main
```

```powershell
# 最新を取得
git fetch origin
git pull origin main
```

```powershell
# 実装ブランチをマージ
git merge feature/impl-001-Slide-Voice-Maker
```

```powershell
# リモートに反映
git push origin main
```

```powershell
# ローカルブランチ削除
git branch -d feature/impl-001-Slide-Voice-Maker
```

```powershell
# リモートブランチ削除（必要なら）
git push origin --delete feature/impl-001-Slide-Voice-Maker
```

コンフリクトが起きた場合

```powershell
# 競合ファイルを確認
git status
```

```powershell
# 手動で修正
git add
git commit
```

```powershell
# 競合解決後
git push origin main
```

ローカル main の変更をリモートに反映（上書き）しない場合、慎重に`reset`（履歴が消えるため注意）。

```powershell
git fetch origin
git reset --hard origin/main
```

---
